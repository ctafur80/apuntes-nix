<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Carlos E. Tafur Egido" />
  <meta name="dcterms.date" content="2025-02-08" />
  <meta name="keywords" content="ciencias de la
computación, informática, tipografía, diseño, documentación, documentación
técnica" />
  <meta name="description" content="Documentación sobre Nix." />
  <title>Documentación sobre Nix</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "“" "”" "‘" "’"; }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #b3adad; background-color: #1e1e1e; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #e8ba9b; } /* Alert */
    code span.an { color: #627a62; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #a37979; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #a69974; } /* ControlFlow */
    code span.ch { color: #a37979; } /* Char */
    code span.cn { color: #a37979; font-weight: bold; } /* Constant */
    code span.co { color: #627a62; } /* Comment */
    code span.cv { color: #627a62; font-weight: bold; } /* CommentVar */
    code span.do { color: #627a62; } /* Documentation */
    code span.dt { color: #abab96; } /* DataType */
    code span.dv { color: #99998d; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #b3b378; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #627a62; font-weight: bold; } /* Information */
    code span.kw { color: #a69974; } /* Keyword */
    code span.op { color: #adad92; } /* Operator */
    code span.ot { color: #b3b378; } /* Other */
    code span.pp { color: #e8ba9b; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #a37979; } /* SpecialChar */
    code span.ss { color: #a17272; } /* SpecialString */
    code span.st { color: #a17272; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #a17272; } /* VerbatimString */
    code span.wa { color: #506350; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="/home/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/css/variables.css" />
  <link rel="stylesheet" href="/home/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/css/base-mobile-first.css" />
  <link rel="stylesheet" href="/home/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/css/tablas.css" />
  <link rel="stylesheet" href="/home/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/css/tabla-contenidos.css" />
  <link rel="stylesheet" href="/home/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/css/codigo.css" />
  <link rel="stylesheet" href="/home/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/css/matematicas.css" />
  <link rel="stylesheet" href="/home/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/css/desktop.css" />
  <nav id="nav">
    <!--<h2></h2>-->
    <ul id="menu">
    </ul>
  </nav>

  <!--<main>-->
  <input type="checkbox" id="toc-check" />
  <label id="toc-toggle" for="toc-check">ToC</label>
  <script src="/Users/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/javascript/breadcrumbs.js"></script>
  <script src="/Users/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/javascript/abre-cierra-nav-bar.js"></script>
  <script src="/Users/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/javascript/nameref.js"></script>
  <script src="/Users/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/javascript/ajustes-mathjax.js"></script>
</head>
<body>
<div id="breadcrumb"></div>
<header id="title-block-header">
<h1 class="title">Documentación sobre Nix</h1>
<p class="author">Carlos E. Tafur Egido</p>
<p class="date">02/08/2025</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introducción" id="toc-introducción">Introducción</a></li>
<li><a href="#introducción-1"
id="toc-introducción-1">Introducción</a></li>
<li><a href="#lenguaje-nix" id="toc-lenguaje-nix">Lenguaje Nix</a>
<ul>
<li><a href="#tipos-de-datos" id="toc-tipos-de-datos">Tipos de
datos</a></li>
<li><a href="#let-bindings" id="toc-let-bindings"><code>let</code>
<em>bindings</em></a></li>
<li><a href="#funciones" id="toc-funciones">Funciones</a></li>
<li><a href="#repl" id="toc-repl">REPL</a></li>
<li><a href="#derivaciones" id="toc-derivaciones">Derivaciones</a></li>
<li><a href="#el-sistema-module" id="toc-el-sistema-module">El sistema
<em>module</em></a></li>
</ul></li>
<li><a href="#paquetes-instalados" id="toc-paquetes-instalados">Paquetes
instalados</a></li>
</ul>
</nav>
<section id="introducción" class="level1">
<h1>Introducción</h1>
<p>Nix es un gestor de paquetes y de entornos. TKTK.</p>
<p>Aunque Nix puede ser usado para instalar y actualizar gran parte del
<em>software</em> de un sistema, es decir, con la misma función con la
que se usan otros gestores de paquetes como Homebrew o APT, se podría
decir que el propósito principal de este es la creación de entornos
(<em>environments</em>). Sería algo similar a, por ejemplo, los entornos
<code>venv</code> del ecosistema Python, o con Npm en JavaScript.</p>
<p>De hecho, en mi caso particular, al igual que le sucede a muchos
otros usuarios de Nix, he pasado a instalar menos <em>software</em> para
todo el sistema (<em>systemwide</em>) en favor de crear más
frecuentemente entornos para propósitos específicos. Por ejemplo, un
<em>software</em> que solía instalar de forma global
(<em>systemwide</em>) en mi sistema de uso personal es
<code>yt-dlp</code>, que permite la descarga de vídeos de sitios web.
Ahora, lo que hago es tener un entorno en el que, cuando se activa, se
tiene, de forma local, dicha herramienta. Esto es muy propicio para
herramientas del tipo de <code>yt-dlp</code>, que en realidad son más
bien bibliotecas (<em>libraries</em>). TKTK.</p>
<p>Para aprender a crear entornos de Nix, o modificar otros que
encuentre ya hechos, lo mejor es hacer el esfuerzo de aprender lo básico
del lenguaje Nix, que es en el que se declaran los entornos. Lo cierto
es que la documentación oficial de Nix no está muy bien hecha. Parece
poco didáctica y la mayoría del material que se encuentra es más bien
para gente con grandes conocimientos de Nix; pero, desde luego, no para
principiantes. Yo comencé a aprender el lenguaje Nix siguiendo <a
href="https://www.youtube.com/watch?v=t8ydCYe9Y3M">un
videotutorial</a>.</p>
<p>En lo que respecta a la creación de entornos para usos más
profesionales y no tan personales, como puede ser alojar ciertos
servicios como un servicio web, uno de base de datos, etc., Nix es muy
útil. En cualquier caso, la opción más popular actualmente es la de usar
contenedores OCI (como, por ejemplo, los de Docker). En cualquier caso,
Nix se puede usar también para declarar contenedores OCI. TKTK.</p>
<p>Actualmente, ha salido un proyecto llamado <a
href="https://docs.determinate.systems/determinate-nix/">Determinate
Nix</a> que es una distribución de Nix (Nix <em>distribution</em>) que
es algo más cómoda de gestionar que instalar Nix de la forma
<q>oficial</q>. Está pensada para ser usada por equipos en una empresa.
Determinate Nix forma parte del proyecto <a
href="https://zero-to-nix.com/">Determinate Systems</a>.</p>
<p>Otra de las ventajas al instalar Nix mediante Determinate Nix es que
se evitan los problemas que da cuando se tiene SELinux y que sí aparecen
al instalarlo de la forma <q>oficial</q>.</p>
<p>En Determinate Systems se tiene también un buen tutorial de Nix,
titulado <a href="https://zero-to-nix.com/">Zero to Nix</a>, que parece
que es algo mejor que la documentación oficial de Nix.</p>
<p>El principal problema que le encuentro es que de serie hace que se
usen <em>flakes</em> para todo, lo que conlleva que tenga que tener
necesariamente conexión a Internet. TKTK. Existe, sin embargo, una forma
de evitarlo TKTK.</p>
</section>
<section id="introducción-1" class="level1">
<h1>Introducción</h1>
<p>Nix es un gestor de paquetes y de entornos. TKTK.</p>
<p>Aunque Nix puede ser usado para instalar y actualizar gran parte del
<em>software</em> de un sistema, es decir, con la misma función con la
que se usan otros gestores de paquetes como Homebrew o APT, se podría
decir que el propósito principal de este es la creación de entornos
(<em>environments</em>). Sería algo similar a, por ejemplo, los entornos
<code>venv</code> del ecosistema Python, o con Npm en JavaScript.</p>
<p>De hecho, en mi caso particular, al igual que le sucede a muchos
otros usuarios de Nix, he pasado a instalar menos <em>software</em> para
todo el sistema (<em>systemwide</em>) en favor de crear más
frecuentemente entornos para propósitos específicos. Por ejemplo, un
<em>software</em> que solía instalar de forma global
(<em>systemwide</em>) en mi sistema de uso personal es
<code>yt-dlp</code>, que permite la descarga de vídeos de sitios web.
Ahora, lo que hago es tener un entorno en el que, cuando se activa, se
tiene, de forma local, dicha herramienta. Esto es muy propicio para
herramientas del tipo de <code>yt-dlp</code>, que en realidad son más
bien bibliotecas (<em>libraries</em>). TKTK.</p>
<p>Para aprender a crear entornos de Nix, o modificar otros que
encuentre ya hechos, lo mejor es hacer el esfuerzo de aprender lo básico
del lenguaje Nix, que es en el que se declaran los entornos. Lo cierto
es que la documentación oficial de Nix no está muy bien hecha. Parece
poco didáctica y la mayoría del material que se encuentra es más bien
para gente con grandes conocimientos de Nix; pero, desde luego, no para
principiantes. Yo comencé a aprender el lenguaje Nix siguiendo <a
href="https://www.youtube.com/watch?v=t8ydCYe9Y3M">un
videotutorial</a>.</p>
<p>En lo que respecta a la creación de entornos para usos más
profesionales y no tan personales, como puede ser alojar ciertos
servicios como un servicio web, uno de base de datos, etc., Nix es muy
útil. En cualquier caso, la opción más popular actualmente es la de usar
contenedores OCI (como, por ejemplo, los de Docker). En cualquier caso,
Nix se puede usar también para declarar contenedores OCI. TKTK.</p>
<p>Actualmente, ha salido un proyecto llamado <a
href="https://docs.determinate.systems/determinate-nix/">Determinate
Nix</a> que es una distribución de Nix (Nix <em>distribution</em>) que
es algo más cómoda de gestionar que instalar Nix de la forma
<q>oficial</q>. Está pensada para ser usada por equipos en una empresa.
Determinate Nix forma parte del proyecto <a
href="https://zero-to-nix.com/">Determinate Systems</a>.</p>
<p>En Determinate Systems se tiene también un buen tutorial de Nix,
titulado <a href="https://zero-to-nix.com/">Zero to Nix</a>, que parece
que es algo mejor que la documentación oficial de Nix.</p>
<p>El principal problema que le encuentro es que de serie hace que se
usen <em>flakes</em> para todo, lo que conlleva que tenga que tener
necesariamente conexión a Internet. TKTK.</p>
<hr />
<p>La instalación que recomiendan desde el propio sitio de Nix es la de
todo el sistema. Para esto, se usa la bandera <code>--daemon</code>. La
instalación para un solo usuario sería con <code>--no-daemon</code>,
pero esta me ha dado problemas.</p>
<hr />
<p>Existen dos formas de usar Nix: la tradicional y la moderna. Esta
última hace uso de algo que llaman <em>flakes</em>. La tradicional tiene
el inconveniente de que, al igual que sucede con los gestores de
contenedores OCI, no es tan determinista, pues TKTK. Por ejemplo, la
versión en concreto de un paquete que tenga incluido en un entorno,
dependerá, hasta cierto punto, de la actualización de los paquetes en su
instalación de Nix. La actualización de los paquetes se hace con</p>
<pre><code>$ nix-channel --update</code></pre>
<p>Con <em>flakes</em> no existe este problema, pues, al activar un
entorno, descargará la última versión TKTK.</p>
<p>El inconveniente de usar <em>flakes</em> es que requiere de añadir
una capa más de conocimiento a quien lo desee usar. Por tanto, lo más
recomendable es que, antes de pasarse a usar Nix mediante la interfaz
<em>flakes</em>, aprenda a usar Nix del modo tradicional.</p>
<p>Por cierto, el uso de <em>flakes</em> suele venir también asociado a
lo que se suele llamar el comando <code>nix</code>, que no es más que
una modernización de los comandos de Nix. En la forma antigua, se suelen
usar comandos de la forma <code>nix-&lt;algo&gt;</code>, mientras que,
en la nueva (haciendo uso del comando <code>nix</code>), se usa un solo
comando, <code>nix</code>, con subcomandos. Por ejemplo,</p>
<pre><code>$ nix profile list</code></pre>
<p>La interfaz <em>flakes</em> se activa en su instalación de Nix
especificando la siguiente línea en el archivo de configuración de
Nix:</p>
<pre><code>experimental-features = nix-command flakes</code></pre>
<p>Dicho archivo puede encontrarse en diversos sitios, según el sistema
operativo y el tipo de instalación de Nix: de un solo usuario o de todo
el sistema (<em>systemwide</em>). En el primer caso, podría estar en
<em>~/.config/nix/nix.conf</em>, mientras que, en el segundo, en
<em>/etc/nix/nix.conf</em>.</p>
<p>También, suelo especificar que se cree en el sistema el grupo de Nix,
llamado <code>nixbld</code>:</p>
<pre><code>build-users-group = nixbld</code></pre>
<p>Deberá añadir también a su usuario a ese grupo:</p>
<pre><code># usermod -aG nixbld &lt;usuario&gt;</code></pre>
<hr />
<p>En cualquier caso, lo que me gusta hacer ahora es instalar Nix
mediante Determinate Systems. Solo hay que seguir las explicaciones del
repositorio <a
href="https://github.com/DeterminateSystems/nix-installer"><code>nix-installer</code></a></p>
<p>Esto activa el uso del comando <code>nix</code> y cambia también los
repositorios. En cuanto a los <em>flakes</em>, se suele usar con estos.
TKTK.</p>
<hr />
<p>En realidad, aunque use entornos para todo, no se le va a llenar
tanto el disco duro, pues en realidad se está haciendo uso de las mismas
instalaciones, las que están en la carpeta <em>/nix</em>. Además,
siempre puede hacer una limpieza luego con</p>
<pre><code>$ nix-collect-garbage -d</code></pre>
<hr />
<p>Quizás, el mejor tutorial para iniciarse en Nix sea <a
href="https://www.youtube.com/watch?v=m4ST2dq10no">este</a>.</p>
<hr />
<p>Para instalar algo del modo tradicional se tiene el comando</p>
<pre><code>$ nix-env -iA nixpkgs.&lt;paquete&gt;</code></pre>
<p>o, si lo prefiere, con el comando <code>nix</code>, con</p>
<pre><code>$ nix profile install nixpkgs#&lt;paquete&gt;</code></pre>
<p>Para actualizar paquetes,</p>
<pre><code>$ nix-env --upgrade</code></pre>
<p>Si tiene el comando <code>nix</code>,</p>
<pre><code>$ nix profile upgrade --all</code></pre>
<p>Por lo que tengo entendido, en principio, si no usa el comando
<code>nix</code>, no puede realizar una búsqueda de paquetes desde la
línea de comandos. Tendrá que recurrir a buscarlos desde la web con la
lista oficial de paquetes de Nix en <code>nixpkgs</code>. Existe una
herramienta que puede instalar mediante la que podría buscar. Esta es
TKTK.</p>
<p>Sin embargo, si tiene configurado el comando <code>nix</code>, sí
podrá buscar. Se podría hacer, por ejemplo, con</p>
<pre><code>$ nix search nixpkgs &quot;&lt;regex&gt;&quot;</code></pre>
<p>Para mostrar la lista de paquetes instalados con Nix en el entorno
global, se haría con</p>
<pre><code>$ nix-env -q</code></pre>
<p>Si lo hace con el comando <code>nix</code>, sería</p>
<pre><code>$ nix profile list</code></pre>
<p>Para desinstalar,</p>
<pre><code>$ nix-env --uninstall &lt;paquete&gt;</code></pre>
<p>Creo que no hace falta especificar el nombre exacto del paquete.</p>
<p>En cuanto a desinstalar un paquete mediante el uso del comando
<code>nix</code></p>
<pre><code>$ nix profile remove &lt;paquete&gt;</code></pre>
<hr />
<p>La instalación que recomiendan desde el propio sitio de Nix es la de
todo el sistema. Para esto, se usa la bandera <code>--daemon</code>. La
instalación para un solo usuario sería con <code>--no-daemon</code>,
pero esta me ha dado problemas.</p>
<hr />
<p>Existen dos formas de usar Nix: la tradicional y la moderna. Esta
última hace uso de algo que llaman <em>flakes</em>. La tradicional tiene
el inconveniente de que, al igual que sucede con los gestores de
contenedores OCI, no es tan determinista, pues TKTK. Por ejemplo, la
versión en concreto de un paquete que tenga incluido en un entorno,
dependerá, hasta cierto punto, de la actualización de los paquetes en su
instalación de Nix. La actualización de los paquetes se hace con</p>
<pre><code>$ nix-channel --update</code></pre>
<p>Con <em>flakes</em> no existe este problema, pues, al activar un
entorno, descargará la última versión TKTK.</p>
<p>El inconveniente de usar <em>flakes</em> es que requiere de añadir
una capa más de conocimiento a quien lo desee usar. Por tanto, lo más
recomendable es que, antes de pasarse a usar Nix mediante la interfaz
<em>flakes</em>, aprenda a usar Nix del modo tradicional.</p>
<p>Por cierto, el uso de <em>flakes</em> suele venir también asociado a
lo que se suele llamar el comando <code>nix</code>, que no es más que
una modernización de los comandos de Nix. En la forma antigua, se suelen
usar comandos de la forma <code>nix-&lt;algo&gt;</code>, mientras que,
en la nueva (haciendo uso del comando <code>nix</code>), se usa un solo
comando, <code>nix</code>, con subcomandos. Por ejemplo,</p>
<pre><code>$ nix profile list</code></pre>
<p>La interfaz <em>flakes</em> se activa en su instalación de Nix
especificando la siguiente línea en el archivo de configuración de
Nix:</p>
<pre><code>experimental-features = nix-command flakes</code></pre>
<p>Dicho archivo puede encontrarse en diversos sitios, según el sistema
operativo y el tipo de instalación de Nix: de un solo usuario o de todo
el sistema (<em>systemwide</em>). En el primer caso, podría estar en
<em>~/.config/nix/nix.conf</em>, mientras que, en el segundo, en
<em>/etc/nix/nix.conf</em>.</p>
<p>También, suelo especificar que se cree en el sistema el grupo de Nix,
llamado <code>nixbld</code>:</p>
<pre><code>build-users-group = nixbld</code></pre>
<p>Deberá añadir también a su usuario a ese grupo:</p>
<pre><code># usermod -aG nixbld &lt;usuario&gt;</code></pre>
<hr />
<p>En cualquier caso, lo que me gusta hacer ahora es instalar Nix
mediante Determinate Systems. Solo hay que seguir las explicaciones del
repositorio <a
href="https://github.com/DeterminateSystems/nix-installer"><code>nix-installer</code></a></p>
<p>Esto activa el uso del comando <code>nix</code> y cambia también los
repositorios. En cuanto a los <em>flakes</em>, se suele usar con estos.
TKTK.</p>
<hr />
<p>En realidad, aunque use entornos para todo, no se le va a llenar
tanto el disco duro, pues en realidad se está haciendo uso de las mismas
instalaciones, las que están en la carpeta <em>/nix</em>. Además,
siempre puede hacer una limpieza luego con</p>
<pre><code>$ nix-collect-garbage -d</code></pre>
<hr />
<p>Quizás, el mejor tutorial para iniciarse en Nix sea <a
href="https://www.youtube.com/watch?v=m4ST2dq10no">este</a>.</p>
<hr />
<p>Para instalar algo del modo tradicional se tiene el comando</p>
<pre><code>$ nix-env -iA nixpkgs.&lt;paquete&gt;</code></pre>
<p>o, si lo prefiere, con el comando <code>nix</code>, con</p>
<pre><code>$ nix profile install nixpkgs#&lt;paquete&gt;</code></pre>
<p>Para actualizar paquetes,</p>
<pre><code>$ nix-env --upgrade</code></pre>
<p>Si tiene el comando <code>nix</code>,</p>
<pre><code>$ nix profile upgrade --all</code></pre>
<p>Por lo que tengo entendido, en principio, si no usa el comando
<code>nix</code>, no puede realizar una búsqueda de paquetes desde la
línea de comandos. Tendrá que recurrir a buscarlos desde la web con la
lista oficial de paquetes de Nix en <code>nixpkgs</code>. Existe una
herramienta que puede instalar mediante la que podría buscar. Esta es
TKTK.</p>
<p>Sin embargo, si tiene configurado el comando <code>nix</code>, sí
podrá buscar. Se podría hacer, por ejemplo, con</p>
<pre><code>$ nix search nixpkgs &quot;&lt;regex&gt;&quot;</code></pre>
<p>Para mostrar la lista de paquetes instalados con Nix en el entorno
global, se haría con</p>
<pre><code>$ nix-env -q</code></pre>
<p>Si lo hace con el comando <code>nix</code>, sería</p>
<pre><code>$ nix profile list</code></pre>
<p>Para desinstalar,</p>
<pre><code>$ nix-env --uninstall &lt;paquete&gt;</code></pre>
<p>Creo que no hace falta especificar el nombre exacto del paquete.</p>
<p>En cuanto a desinstalar un paquete mediante el uso del comando
<code>nix</code></p>
<pre><code>$ nix profile remove &lt;paquete&gt;</code></pre>
</section>
<section id="lenguaje-nix" class="level1">
<h1>Lenguaje Nix</h1>
<p>Aunque aquí vamos a seguir el videotutorial titulado Nix From Nothing
#1, que está bien para una primera aproximación, los conceptos del
lenguaje Nix vienen mejor explicados en otros tutoriales como <a
href="https://nix.dev/tutorials/nix-language">el de Nix.dev</a>. Además,
se tiene como referencia <a
href="https://nixos.org/manual/nix/stable/language/">lo que explican</a>
en el manual oficial, que le dará un conocimiento más completo.</p>
<section id="tipos-de-datos" class="level2">
<h2>Tipos de datos</h2>
<p>La estructura de datos principal de Nix es la que se conoce como
<em>conjunto de atributos</em> (<em>attributes set</em>), que sería en
cierto modo parecido a los diccionarios de Python (tiene muchos nombres;
además de estos, tabla <em>hash</em>, arreglo asociativo, mapas, etc.).
Tiene una sintaxis muy parecida a la del formato JSON.</p>
<p>También, hay que tener en cuenta que, ya que se adhiere bastante al
paradigma funcional, en Nix lo que se maneja son expresiones
(<em>expressions</em>); no afirmaciones (<em>statements</em>). Esto
permite al lenguaje prescindir del signo de punto y coma
(<code>;</code>, <em>semicolon</em>) al final. En cualquier caso, por
razones de expresividad, se ha dado otro uso a dicho símbolo;
concretamente, se usa para separar los distintos elementos dentro de un
conjunto de atributos.</p>
<p>Lo siguiente sería un literal de un conjunto de atributos. Por
ejemplo,</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">name1</span> <span class="op">=</span> <span class="st">&quot;value1&quot;</span><span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">name2</span> <span class="op">=</span> <span class="st">&quot;value2&quot;</span><span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Tal y como hemos dicho, sería equivalente a un diccionario.</p>
<p>Si en su instalación de Nix tiene activado <em>flakes</em>, si
introduce lo anterior en un archivo como, por ejemplo,
<em>example.nix</em>, podemos evaluar ese conjunto de atributos con el
comando siguiente:</p>
<pre><code>$ nix eval --file example.nix
{ name1 = &quot;value1&quot;; name2 = &quot;value2&quot;; }</code></pre>
<p>El uso del punto y coma en los elementos de un conjunto de atributos
es obligatorio, incluso en el último de estos (de los elementos).</p>
<p>Otro tipo de dato estructurado que se tiene son las listas
(<em>lists</em>). Serían lo mismo que las listas en Python (mutabilidad?
mejor, las tuplas?). TKTK. Un literal de lista sería, por ejemplo,</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="op">]</span></span></code></pre></div>
<p>El espacio o nuevo renglón es el que sirve para delimitar los
elementos en la lista. La anterior sería igual a la siguiente:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">]</span></span></code></pre></div>
<p>Aunque se suele usar como regla de estilo dejar un espacio entre los
delimitadores y los elementos en su interior, este lo podríamos eliminar
si lo deseáramos:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span><span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span><span class="op">]</span></span></code></pre></div>
</section>
<section id="let-bindings" class="level2">
<h2><code>let</code> <em>bindings</em></h2>
<p>Aunque se tenga una expresión declarativa, se pueden especificar
valores de variables en esta, tal y como se hace, por ejemplo, en las
<em>list comprehensions</em> de Python. En Nix sucede algo similar. Para
esto se usan los <code>let</code> <em>bindings</em>. Por ejemplo,</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">myNumber</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    myNumber <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<p>Ojo con el punto y coma antes del <code>in</code>. Al ser un conjunto
de atributos lo que introducimos dentro de <code>let</code>, debrá tener
punto y coma cada uno de los elementos ahí. Lo que hay tras
<code>in</code> es una expresión que hace uso de ese conjunto de
atributos.</p>
<pre><code>$ nix eval --file 01.nix
43</code></pre>
<p>Como ve, sigue siendo una expresión pero esta vez esta tiene en
cuenta el valor de la variable <code>myNumber</code>.</p>
<p>Lo considero en realidad una expresión porque lo importante es lo que
va tras la palabra clave <code>in</code>. Lo que va entre
<code>let</code> e <code>in</code> es simplemente para hacer a la
expresión consciente de los valores de ciertas variables. En cualquier
caso, ya no estamos en un paradigma funcional puro; bueno, eso depende
de cómo se considere TKTK.</p>
<p>En cualquier caso, esas variables están confinadas a esa expresión,
es decir, no tenemos variables globales y, por tanto, no se puede
afirmar que el programa ejecutándose pase por estados diversos.</p>
</section>
<section id="funciones" class="level2">
<h2>Funciones</h2>
<p>Nix cuenta también, evidentemente, con funciones. Por ejemplo, así se
definiría y se invocaría una función que decidimos llamar
<code>greet()</code>.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">greet</span> <span class="op">=</span> <span class="va">name</span><span class="op">:</span> <span class="st">&quot;Hello, </span><span class="sc">${</span>name<span class="sc">}</span><span class="st">!&quot;</span><span class="op">;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    greet <span class="st">&quot;Carlos&quot;</span></span></code></pre></div>
<p>Como ve, la función se define asignando una definición de función
anónima (<em>anonymous function</em>; a estas también las suelen llamar
<em>funciones lambda</em>, <em>lambda functions</em>) a una variable (en
este caso, <code>greet</code>), y esto se hace dentro de la parte
<code>let</code> de un <code>let</code> <em>binding</em>.</p>
<p>En la definición de la función, lo primero que se pone son los
parámetros (o parámetros formales). A la derecha de estos, un signo de
dos puntos (<code>:</code>, <em>colon</em>), y a su derecha, la propia
definición de la función; o su firma (<em>signature</em>), se podría
decir también.</p>
<p>En la parte <code>in</code>, se puede invocar la función, con los
argumentos (o parámetros reales) que deseemos. En este caso, el
argumento es el literal de cadena <code>Carlos</code>. Las comillas
sirven para delimitar al literal de cadena y, en este caso, no forman
parte del mismo; al igual que suele suceder con la mayoría de lenguajes
de programación.</p>
<p>La sintaxis suele evitar el uso de signos de llaves
(<code>{ }</code>) y paréntesis (<code>()</code>). También, como ve, se
hace interpolación de cadena (<em>string interpolation</em>, o plantilla
de cadena, <em>template string</em>) en los literales de cadena, al
igual que en tantos otros lenguajes. En este caso, tiene la forma
<code>${&lt;var&gt;}</code> donde <code>&lt;var&gt;</code> será la
variable de la que se tomará el valor para insertar en esa parte de la
cadena.</p>
<p>Al evaluar la expresión <code>let-in</code> anterior, dará como
resultado</p>
<pre><code>$ Hello, Carlos!</code></pre>
<p>como es evidente.</p>
<p>Si deseamos una función que tenga más de un parámetro de entrada, se
puede usa lo que en programación funcional llaman el <em>currying</em>,
es decir, hacer uso de una función dentro de otra.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">greet</span> <span class="op">=</span> <span class="va">greeting</span><span class="op">:</span> <span class="va">name</span><span class="op">:</span> <span class="st">&quot;</span><span class="sc">${</span>greeting<span class="sc">}</span><span class="st">, </span><span class="sc">${</span>name<span class="sc">}</span><span class="st">!&quot;</span><span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    greet <span class="st">&quot;Howdy&quot;</span> <span class="st">&quot;Carlos&quot;</span></span></code></pre></div>
<p>que devolverá</p>
<pre><code>$ Howdy, Carlos!</code></pre>
<p>Como ve, cuando se dan varios argumentos a una llamada de una
función, estos se separan mediante espacio.</p>
<p>Ahora, vamos a mezclar las funciones con conjuntos de atributos.</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="va">secret</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mySuperSecretValue</span> <span class="op">=</span> secret<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="st">&quot;abcd&quot;</span></span></code></pre></div>
<p>que daría</p>
<pre><code>$ nix eval --file example.nix
{ mySuperSecretValue = &quot;abcd&quot;; }</code></pre>
<p>En este caso, la definición de la función es básicamente un conjunto
de atributos, como puede ver. Por tanto, lo que devuelve la función será
eso mismo.</p>
<p>Por cierto, de momento, como verá, estamos haciendo uso de argumentos
posicionales en las funciones. Ahora, vamos a ver cómo se haría uso de
argumentos nombrados.</p>
<p>También, se le podría pasar un conjunto de atributos como argumento a
la función.</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="va">secret</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mySuperSecretValue</span> <span class="op">=</span> secret<span class="op">;</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que daría</p>
<pre><code>$ nix eval --file example.nix
{ mySuperSecretValue = { key = &quot;my_secret&quot;; value = &quot;super-secret&quot;; }; }</code></pre>
<p>Ojo con el punto y coma tras <code>"super-secret"</code>. En
realidad, aquí no hemos hecho nada, es decir, este ejemplo no tiene
ningún sentido.</p>
<p>Pero quizás no era eso lo que deseábamos hacer, sino lo
siguiente:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mySuperSecretValue</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ mySuperSecretValue = &quot;super-secret&quot;; }</code></pre>
<p>Como ve, solo muestra el atributo al que se le da hado un valor. El
otro, al no haber recibido ningún valor, no lo muestra, pues, en la
definición de la función, no se da ningún uso al parámetro
<code>key</code>.</p>
<p>¿Pero cómo podríamos modificar esta función para que sí que haga uso
del parámetro <code>key</code> en la clave del conjunto de atributos? Es
muy sencillo; no hay más que usar la interpolación de cadena:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;</span><span class="sc">${</span>key<span class="sc">}</span><span class="st">&quot;</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ my_secret = &quot;super-secret&quot;; }</code></pre>
<p>Podríamos haber puesto la clave sin comillas y también sería
válido.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>        ${<span class="va">key</span><span class="op">}</span> = value<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ my_secret = &quot;super-secret&quot;; }</code></pre>
<p>Si en la definición de la función solo se hubiera especificado el
parámetro <code>value</code> y, luego, en la llamada, se ponen ambos,
nos dará un error.</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mySuperSecretValue</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que daría</p>
<pre><code>❯ nix eval --file example.nix
error: &#39;makeSecret&#39; at /Users/ctafur/temp/nix/nix-from-nothing-tuto/dos/example.nix:2:18 called with unexpected argument &#39;key&#39;

       at /Users/ctafur/temp/nix/nix-from-nothing-tuto/dos/example.nix:6:5:

            5| in
            6|     makeSecret { key = &quot;my_secret&quot;; value = &quot;super-secret&quot;; }
             |     ^
            7|
(use &#39;--show-trace&#39; to show detailed location information)</code></pre>
<p>Si deseamos dejar abierta la posibilidad de que se pueda llamar a
otros argumentos no especificados en la definición de una función, se
puede usar la notación de elipsis (<em>ellipsis</em>): <code>...</code>,
para indicarlo.</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">value</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mySuperSecretValue</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ mySuperSecretValue = &quot;super-secret&quot;; }</code></pre>
<p>Es decir, tampoco hace uso del parámetro <code>key</code>, pero esta
vez no da error.</p>
<p>Advierta que, en el literal de conjunto de atributos que se usa en la
definición de la función, las variables en las claves, para ser
sustituidas por su valor, deben usar la notación de interpolación de
cadena, mientras que con los valores no sucede esto. Es decir, lo
siguiente</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">key</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>daría</p>
<pre><code>$ nix eval --file example.nix
{ key = &quot;super-secret&quot;; }</code></pre>
<p>que no es lo que deseábamos en este caso.</p>
<p>También, se podría hacer más dinámico:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;</span>user-key:<span class="sc">${</span>key<span class="sc">}</span><span class="st">&quot;</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ &quot;user-key:my_secret&quot; = &quot;super-secret&quot;; }</code></pre>
<p>Si queremos hacer lo siguiente:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">value</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>se puede hacer de forma abreviada usando el enunciado
<code>inherit</code>:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">inherit</span> value<span class="op">;</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>En ambos casos, se tendría como resultado</p>
<pre><code>$ nix eval --file example.nix
{ value = &quot;super-secret&quot;; }</code></pre>
<p>Imagino que el uso que se da a <code>inherit</code> será para hacer
pruebas sobre los estados de las variables, al igual que en Python se
hace con <code>f"variable="</code>.</p>
<p>También, se puede tener una función dentro de un conjunto de
atributos. La forma de acceder a este es mediante la notación punto.</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">conj_atrib</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">greet</span> <span class="op">=</span> <span class="va">greeting</span><span class="op">:</span> <span class="va">name</span><span class="op">:</span> <span class="st">&quot;</span><span class="sc">${</span>greeting<span class="sc">}</span><span class="st">, </span><span class="sc">${</span>name<span class="sc">}</span><span class="st">!&quot;</span><span class="op">;</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    conj_atrib.greet <span class="st">&quot;Howdy&quot;</span> <span class="st">&quot;Carlos&quot;</span></span></code></pre></div>
<p>TKTK.</p>
<p>También, debe saber que los comentarios son el símbolo <code>#</code>
para comentar hasta final de línea, y, <code>/*</code> y
<code>*/</code>, para abrir y cerrar, respectivamente, un comentario
multilínea.</p>
<!-- --------------------------------------------------------------- -->
<p>Llegados a este punto, básicamente hemos visto lo básico del lenguaje
Nix. Lo natural sería que el paso siguiente consistiera en integrar este
conocimiento con Nixpkgs, que son los paquetes junto con una serie de
fuciones. TKTK. Entre las cosas que haremos con Nixpkgs se encuentran
crear <em>helper functions</em> para mapas (<em>maps</em>), para filtros
(<em>filters</em>), etc.</p>
<p>Vamos a ver primero cómo se importan otros archivos de Nix.</p>
<p>Creamos el archivo <em>other-file.nix</em> con el contenido
siguiente:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">greet</span> <span class="op">=</span> <span class="va">name</span><span class="op">:</span> <span class="st">&quot;Hello, </span><span class="sc">${</span>name<span class="sc">}</span><span class="st">!&quot;</span><span class="op">;</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Como ve, lo único que contiene es un conjunto de atributos cuyo único
elemento tiene por clave la cadena <code>"greet"</code> y, por valor,
una función anónima.</p>
<p>Ahora, vamos a crear otro archivo Nix, que llamaremos
<em>example.nix</em>, desde el que cargaremos el anterior archivo Nix,
<em>other-file.nix</em>. En <em>example.nix</em>, incluiremos lo
siguiente:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">myLibrary</span> <span class="op">=</span> <span class="bu">import</span> <span class="ss">./other-file.nix</span><span class="op">;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    myLibrary</span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ greet = &lt;LAMBDA&gt;; }</code></pre>
<p>En <em>example.nix</em> se la incluido, dentro de un <code>let</code>
<em>binding</em>, una importación del contenido de otro archivo Nix;
concretamente, de <em>other-file.nix</em>. El resultado de evaluar
<em>example.nix</em> es el esperado. En la información que nos da la
evaluación, la parte <code>&lt;LAMBDA&gt;</code> indica una función
anónima, pero sin especificar el contenido de esta. En cualquier caso,
la forma de invocarla es usar la clave asociada a la misma en la tabla,
es decir, <code>greet</code>. Pero ese atributo está dentro del conjunto
de atributos <code>myLibrary</code>, por lo que deberá llamar al
<code>greet</code> de <code>myLibrary</code>, cosa que puede hacer
usando el operador punto, tal y como se explicó antes.</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">myLibrary</span> <span class="op">=</span> <span class="bu">import</span> <span class="ss">./other-file.nix</span><span class="op">;</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    myLibrary.greet <span class="st">&quot;Carlos&quot;</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
&quot;Hello, Carlos!&quot;</code></pre>
<p>Esto mismo se puede hacer con los paquetes Nix.</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt;<span class="op">;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    pkgs</span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
&lt;LAMBDA&gt;</code></pre>
<p>Como es una función (ya que pone <code>&lt;LAMBDA&gt;</code>, se
debería especificar algún parámetro, o varios de estos en un conjunto de
atributos. En realidad, <code>&lt;nixpkgs&gt;</code> es una función que
a su vez contiene muchas cosas a distintos niveles de anidamiento:
funciones y conjuntos de atributos, principalmente.</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{};</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>    pkgs.lib</span></code></pre></div>
<p>Esto nos mostrará todo lo que hay en el atributo <code>lib</code>
dentro de la lista de paquetes (<code>nixpkgs</code>). La salida es
bastante grande. Tenga cuidado de no intentar llamar a
<code>pkgs</code>, que llamaría a todos los paquetes. Lo hice, al seguir
este tutorial, y tuve que terminar reiniciando el computador, ya que son
muchos los paquetes incluidos actualmente.</p>
<p>Con <code>&lt;nixpkgs&gt;</code>, lo que hemos hecho es usar esa
biblioteca tomada de nuestro entorno, es decir, de la de nuestra
instalación de Nix. Se podría haber optado, alternativamente, a tomarla
de su repositorio en GitHub, por ejemplo, o de algún otro sitio,
especificando la URL que correspondiera.</p>
<p>Con el comando siguiente, se puede consultar de dónde lo toma su
instalación local:</p>
<pre><code>$ nix-channel --list
nixpkgs https://nixos.org/channels/nixpkgs-unstable</code></pre>
</section>
<section id="repl" class="level2">
<h2>REPL</h2>
<p>Una forma bastante cómoda de hacer pruebas con la biblioteca
<code>nixpkgs</code> es desde el REPL de Nix. Si tiene activado
<em>flakes</em>, se entra con</p>
<pre><code>$ nix repl
nix-repl&gt;</code></pre>
<p>Una diferencia con el lenguaje en los archivos es que en el REPL no
tiene que terminar con punto y coma. También, se pueden asignar valores
a variables sin usar <code>let</code>-<code>in</code>.</p>
<p>Tiene autocompletado, por lo que puede ir viendo los elementos de las
distintas bibliotecas.</p>
<pre><code>nix-repl&gt; pkgs = import &lt;nixpkgs&gt; {}
nix-repl&gt; pkgs.lib.</code></pre>
<p>Si ahí, sin pulsar <kbd>Intro</kbd>, pulsa <kbd>Tab</kbd> para hacer
<em>tab-completion</em>, se mostrará todo lo que hay bajo el conjunto de
atributos <code>lib</code> de <code>nixpkgs</code>.</p>
<p>Además de los distintos elementos de <code>nixpkgs</code>, nuestra
instalación trae siempre ciertos elementos de serie. A esto los llaman
<em>builtins</em>. Puede consultarlos también:</p>
<pre><code>nix-repl&gt; builtins.</code></pre>
<p>y pulse <kbd>Tab</kbd>. Por ejemplo, tenemos la función
<code>derivation</code> dentro de <code>builtins</code>, a la que podemo
hacer alusión con <code>builtins.derivation</code>.</p>
<pre><code>nix-repl&gt; builtins.derivation
«lambda @ /builtin/derivation.nix:5:1»</code></pre>
<p>Como vemos, es una función, ya que pone <code>lambda</code>. Esta
función tiene varios argumentos obligatorios. Si tratamos de invocarla
sin esos argumentos,</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="bu">builtins</span>.<span class="bu">derivation</span> <span class="op">{}</span></span></code></pre></div>
<p>nos dará un error.</p>
<pre><code>$ nix eval --file example.nix
error:
       … while evaluating the attribute &#39;outPath&#39;

         at /builtin/derivation.nix:19:9: (source not available)

       … while calling the &#39;getAttr&#39; builtin

         at /builtin/derivation.nix:19:19: (source not available)

       (stack trace truncated; use &#39;--show-trace&#39; to show the full trace)

       error: attribute &#39;name&#39; missing</code></pre>
<p>Vamos a ver los argumentos:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="bu">builtins</span>.<span class="bu">derivation</span> <span class="op">{</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-derivation&quot;</span><span class="op">;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="derivaciones" class="level2">
<h2>Derivaciones</h2>
<p>Dentro de los elementos que vienen de serie en nuestra instalación de
Nix, que se encuentran en el conjunto de atributos
<code>builtins</code>, se tiene la función <code>derivation</code>.
Sabemos que se trata de una función porque, si la invocamos desde el
REPL, muestra lo siguiente:</p>
<pre><code>nix-repl&gt; builtins.derivation
«lambda @ /builtin/derivation.nix:5:1»</code></pre>
<p>Como ve, nos referimos a esta empleando la notación punto:
<code>builtins.derivation</code>. Aun así, esta no se puede invocar sin
especificar los valores para ciertos parámetros.</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="bu">builtins</span>.<span class="bu">derivation</span> <span class="op">{</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-derivation&quot;</span><span class="op">;</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;x86_64-darwin&quot;</span><span class="op">;</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">builder</span> <span class="op">=</span> <span class="st">&quot;/bin/sh&quot;</span><span class="op">;</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">args</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;-c&quot;</span> <span class="st">&quot;echo Hello &gt; $out&quot;</span> <span class="op">];</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Estos parámetros son <code>name</code>, que es el nombre que queramos
que tenga esta. También, <code>system</code>, donde se debe especificar
el nombre del sistema sobre el que se podrá ejecutar. Se podría
consultar en el REPL del modo siguiente:</p>
<pre><code>nix-repl&gt; builtins.attrNames pkgs.lib.platforms</code></pre>
<p>Puede ser, por ejemplo, para Linux en arquitectura x86 de 64 bits,
<code>x86_64-linux</code>.</p>
<p>También es obligatorio el parámetro <code>builder</code>, que es el
programa del que se va a crear la derivación. Como parámetro opcional,
complementando al <em>software</em> que se incluya en
<code>builder</code>, se tiene el parámetro <code>args</code>, que
especifica una lista con los argumentos que deseamos que tenga dicho
comando.</p>
<p>En este ejemplo, se ha especificado que se construya el
<em>software</em> que se encuentra en el archivo <em>/bin/sh</em>.
Además, que se le pasen como argumentos <code>-c</code> y
<code>echo Hello &gt; $out</code>, cosa que quiere decir que se muestre
en la salida estándar de ese <em>shell</em> (_/bin/<em>sh</em>) la
cadena <code>Hello</code>. Advierta que <code>$out</code> tiene un
significado especial en Nix. Indica la variable de salida, es decir, a
dónde irá la salida del programa TKTK.</p>
<p>Una vez construida la espeficicación de la derivación, puede
evaluarla, aunque no es un paso necesario. Se hace con</p>
<pre><code>$ nix eval --file ./example.nix
{ all = [ «repeated» ]; args = [ &quot;-c&quot; &quot;echo Hello &gt; $out&quot; ]; builder = &quot;/bin/sh&quot;; drvAttrs = { args = «repeated»; builder = &quot;/bin/sh&quot;; name = &quot;my-derivation&quot;; system = &quot;x86_64-darwin&quot;; }; drvPath = &quot;/nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv&quot;; name = &quot;my-derivation&quot;; out = «repeated»; outPath = &quot;/nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation&quot;; outputName = &quot;out&quot;; system = &quot;x86_64-darwin&quot;; type = &quot;derivation&quot;; }</code></pre>
<p>Como ve, nos devuelve un conjunto de atributos que especifica una
derivación. En el atributo <code>drvPath</code> muestra el archivo donde
estará la derivación, cuando la creemos. Siempre lo hace bajo
<em>/nix/store</em>. El nombre del archivo de derivación se construye
con un <em>hash</em> que ha calculado con los datos de entrada seguida
de un guión y del nombre que le hemos dado en el parámetro
<code>name</code>.</p>
<p>La razón de ser de ese <em>hash</em> es para que se puedan tener
instancias distintas de un mismo <em>software</em>.</p>
<p>Con el atributo <code>outPath</code> nos muestra la ruta del
ejecutable que se obtendrá al final cuando se construya el ejecutable a
partir de la derivación. También se encontrará ubicado bajo la carpeta
<em>/nix/store</em>.</p>
<p>Para crear realmente la derivación, cosa que llaman
<em>instanciar</em> la derivación, se hace:</p>
<pre><code>$ nix-instantiate ./example.nix
warning: you did not specify &#39;--add-root&#39;; the result might be removed by the garbage collector
/nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv</code></pre>
<p>Se ha hecho de forma correcta, aunque muestre una advertencia
(<em>warning</em>). No se preocupe por esta.</p>
<p>Ahí vuelve a mostrar el mismo archivo de derivación que puso antes.
Puede comprobar que efectivamente ahora existe dicho archivo.</p>
<pre><code>$ ls -lah /nix/store/46wid*
-r--r--r--  1 root  nixbld   286B Jan  1  1970 /nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv</code></pre>
<p>De hecho, en la carpeta <em>/nix/store</em> se tienen también las
derivaciones de todos los paquetes instalados mediante Nix, incluso los
que ha instalado de otros, como puede comprobar con:</p>
<pre><code>$ ls -lah /nix/store/*.drv</code></pre>
<p>Si abre dicho archivo, es decir
<em>/nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv</em>,</p>
<pre><code>Derive([(&quot;out&quot;,&quot;/nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation&quot;,&quot;&quot;,&quot;&quot;)],[],[],&quot;x86_64-darwin&quot;,&quot;/bin/sh&quot;,[&quot;-c&quot;,&quot;echo Hello &gt; $out&quot;],[(&quot;builder&quot;,&quot;/bin/sh&quot;),(&quot;name&quot;,&quot;my-derivation&quot;),(&quot;out&quot;,&quot;/nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation&quot;),(&quot;system&quot;,&quot;x86_64-darwin&quot;)])</code></pre>
<p>advertirá que es básicamente lo mismo que nos mostró con la
evaluación de la espeficicación de la evaluación.</p>
<p>Una vez que se tiene creada la derivación, se debe realizar esta
(<em>to realise it</em>). Se hace del modo siguiente:</p>
<pre><code>$ nix-store --realise /nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv
this derivation will be built:
  /nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv
building &#39;/nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv&#39;...
warning: you did not specify &#39;--add-root&#39;; the result might be removed by the garbage collector
/nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation</code></pre>
<p>Nos devuelve la misma advertencia de antes. El comando nos devuelve
la ruta del ejecutable construido:
<code>/nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation</code>,
que es la misma que la del parámetro <code>outPath</code> de antes.
Vamos a ejecutarlo para comprobar que se ejecuta correctamente:</p>
<pre><code>$ cat /nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation
Hello</code></pre>
<p>En cualquier caso, esta forma de construir paquetes tiene muchos
inconvenientes. Me refiero a mediante la función <code>derivation</code>
de <code>builtins</code>. Por ejemplo, en este caso, dependemos de que
se encuentre instalado previamente en el sistema el <em>software</em>
<code>sh</code>, en la ruta que hemos especificado (<em>/bin/sh</em>);
cosa que además debemos conocer. También, que tenemos que TKTK.</p>
<p>Es decir, de este modo, tal y como lo hemos construido
(<em>build</em>) el paquete, tenemos que hacer por nosotros mismos
prácticamente todo.</p>
<p>La forma que tenemos de hacernos la vida más fácil aquí es haciendo
uso de <code>nixpkgs</code>. Vamos a modificarlo para hacerlo más
cómodamente.</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{};</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">builtins</span>.<span class="bu">derivation</span> <span class="op">{</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-derivation&quot;</span><span class="op">;</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;x86_64-darwin&quot;</span><span class="op">;</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">builder</span> <span class="op">=</span> pkgs.bash<span class="op">;</span></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">args</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;-c&quot;</span> <span class="st">&quot;echo Hello &gt; $out&quot;</span> <span class="op">];</span></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>También, en lugar de usar los comandos <code>nix-instantiate</code> y
<code>nix-store --realise</code>, usaremos</p>
<pre><code>$ nix build --file ./example.nix
error: builder for &#39;/nix/store/vkhirw1vzwzxlpa9mrc0qvfmxf8jxrq4-my-derivation.drv&#39; failed with exit code 71;
       last 1 log lines:
       &gt; sandbox-exec: execvp() of &#39;/nix/store/a0a4dznjllw3bicpccvm2nc74zymgyiq-bash-5.2p26&#39; failed: Permission denied
       For full logs, run &#39;nix log /nix/store/vkhirw1vzwzxlpa9mrc0qvfmxf8jxrq4-my-derivation.drv&#39;.</code></pre>
<p>Bueno, esto ha fallado. A él también le falló. Vamos a usar mejor
otras cosas distintas al conjunto de atributos <code>derivation</code>.
Vamos a usar, en su lugar, un <em>helper</em> llamado
<code>runCommand</code> dentro de <code>nixpkgs</code>.</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{};</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    pkgs.runCommand <span class="st">&quot;my-derivation&quot;</span> <span class="op">{}</span> <span class="st">&#39;&#39;</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a><span class="st">        echo Hello &gt; $out</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a><span class="st">    &#39;&#39;</span></span></code></pre></div>
<p>Los comentarios multilíena se encierran en Nix entre dos comillas
simples (<code>''</code>).</p>
<p>Ahora, no se queja:</p>
<pre><code>$ nix build --file ./example.nix</code></pre>
<p>A diferencia de antes, ahora no nos ha dado la ruta en la que se
encuentra el paquete instalado. Pero, si consultamos el contenido de la
carpeta desde la que hemos lanzado el comando <code>nix build</code>,
vemos un archivo llamado <em>result</em>, que no estaba antes. Es un
vínculo simbólico a dicho ejecutable.</p>
<pre><code>$ ls -lah
total 16
drwxr-xr-x  5 ctafur  staff   160B Apr 19 13:19 .
drwxr-xr-x  6 ctafur  staff   192B Apr 18 09:45 ..
-rw-r--r--  1 ctafur  staff   114B Apr 19 13:18 example.nix
-rw-r--r--  1 ctafur  staff    48B Apr 18 10:43 other-file.nix
lrwxr-xr-x  1 ctafur  staff    57B Apr 19 13:19 result -&gt; /nix/store/4f1szldkaak4i2zw59wp7mjfjgmj4cqq-my-derivation</code></pre>
<p>No hace falta copiar la ruta. Podemos llamar directamente a
<em>result</em> y se ejecutará el paquete.</p>
<pre><code>$ cat result
Hello</code></pre>
<p>Existen otros <em>wrappers</em> de <code>derivation</code> que se
suelen usar más que <code>runCommand</code>. Por ejemplo,
<code>mkDerivation</code>.</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{};</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    pkgs.stdenv.mkDerivation <span class="op">{</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-derivation&quot;</span><span class="op">;</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">builder</span> <span class="op">=</span> <span class="st">&quot;/bin/sh&quot;</span><span class="op">;</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">args</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;-c&quot;</span> <span class="st">&quot;echo Hello &gt; $out&quot;</span> <span class="op">];</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">src</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>El parámetro <code>src</code> es obligatorio en esta función. Es
importante no olvidar que una derivación requiere de una fuente
(<em>source</em>). En este caso, le hemos dado la carpeta actual.</p>
<p>Se instalaría del mismo modo que antes:</p>
<pre><code>$ nix build --file ./example.nix
$ cat result
Hello</code></pre>
<p>La función <code>mkDerivation</code> hace más cosas que
<code>runCommand</code>. Por ejemplo, permite crear fases
(<em>phases</em>) en la construcción del paquete, que sería parecido a
las capas en la construcción de una imagen de contenedores OCI.</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{};</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    pkgs.stdenv.mkDerivation <span class="op">{</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-derivation&quot;</span><span class="op">;</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">src</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">installPhase</span> <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a><span class="st">            echo Hello &gt; $out</span></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a><span class="st">        &#39;&#39;</span><span class="op">;</span></span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Se construye como antes:</p>
<pre><code>$ nix build --file ./example.nix
$ cat result
Hello</code></pre>
<p>La diferencia entre <code>mkDerivation</code> y
<code>runCommand</code> está en que este último está más pensado para
introducir <em>scripts</em> de <em>shell</em>, mientras que el primero
es para hacer derivaciones realmente. Siempre se pueden hacer con
<code>derivation</code>, pero es mucho más trabajoso y hay que tener en
cuenta muchas más cosas. Sin embargo, con estos dos <em>helpers</em> o
<em>wrappers</em> es mucho más cómodo.</p>
</section>
<section id="el-sistema-module" class="level2">
<h2>El sistema <em>module</em></h2>
<p>Es una forma genérica de proporcionar configuración.</p>
<p>Vamos a probar con estos en el REPL.</p>
<p>Lo primero que vamos a hacer es cargar <code>nixpkgs</code>:</p>
<pre><code>nix-repl&gt; :l &lt;nixpkgs&gt;</code></pre>
<p>Ahora,</p>
<pre><code>nix-repl&gt; modulea = { options.a.enable = lib.mkEnable.Options; }</code></pre>
<!-- MINUTO 55. Lo cierto es que esta parte es bastante caótica. No sé qué
es lo que quería hacer ahí. -->
<p>Es decir,</p>
<pre><code>nix-repl&gt; :l &lt;nixpkgs&gt;
nix-repl&gt; modulea = { options.a.enable = lib.mkEnable.Options; }
nix-repl&gt; result = lib.evalModules { modules = [ modulea ]; }
nix-repl&gt; result
{ _module = { ... }; _type = &quot;configuration&quot;; class = null; config = { ... }; extendModules = «lambda @ /nix/store/kldyrambq3k5kgg61x2qrcwnyljmfwqq-nixpkgs/nixpkgs/lib/modules.nix:303:23»; options = { ... }; type = { ... }; }
nix-repl&gt; result.options
{ _module = { ... }; a = { ... }; }
nix-repl&gt; result.options.a
{ enable = { ... }; }
nix-repl&gt; result.options.a.enable
{ __toString = «lambda @ /nix/store/kldyrambq3k5kgg61x2qrcwnyljmfwqq-nixpkgs/nixpkgs/lib/modules.nix:816:22»; _type = &quot;option&quot;; declarationPositions = [ ... ]; declarations = [ ... ]; default = false; definitions = [ ... ]; definitionsWithLocations = [ ... ]; description = &quot;Whether to enable A.&quot;; example = true; files = [ ... ]; highestPrio = 1500; isDefined = true; loc = [ ... ]; options = [ ... ]; type = { ... }; value = false; }
nix-repl&gt;
nix-repl&gt;
nix-repl&gt; moduleb = { options.b.enable = lib.mkEnableOption &quot;B&quot;; } 
nix-repl&gt; result = lib.evalModules { modules = [ moduleb ]; }      
nix-repl&gt; result.options
{ _module = { ... }; b = { ... }; }
nix-repl&gt;
nix-repl&gt; result.options.b.enable
{ __toString = «lambda @ /nix/store/kldyrambq3k5kgg61x2qrcwnyljmfwqq-nixpkgs/nixpkgs/lib/modules.nix:816:22»; _type = &quot;option&quot;; declarationPositions = [ ... ]; declarations = [ ... ]; default = false; definitions = [ ... ]; definitionsWithLocations = [ ... ]; description = &quot;Whether to enable B.&quot;; example = true; files = [ ... ]; highestPrio = 1500; isDefined = true; loc = [ ... ]; options = [ ... ]; type = { ... }; value = false; }</code></pre>
<p>Como puede ver, ambos han sido combinados. Es decir, todos los
módulos colapsan (<em>collapse</em>).</p>
<p>Todos los módulos toman 3 cosas: <code>options</code>,
<code>config</code> y <code>imports</code>. El último ya lo hemos visto.
<code>options</code> es lo que hemos visto ahora mismo. Donde las cosas
sí son algo diferentes es con <code>config</code>.</p>
<pre><code>nix-repl&gt; moduleb = { config = { a.enable = true; }; }
nix-repl&gt; result = lib.evalModules { modules = [ modulea moduleb ]; }
nix-repl&gt; result.config.a.enable
true</code></pre>
<p>Sin embargo,</p>
<pre><code>nix-repl&gt; result = lib.evalModules { modules = [ moduleb ]; }
nix-repl&gt; result.config.a.enable
error: The option `a&#39; does not exist. Definition values:
       - In `&lt;unknown-file&gt;&#39;:
           {
             enable = true;
           }

       It seems as if you&#39;re trying to declare an option by placing it into `config&#39; rather than `options&#39;!</code></pre>
<p>Esto sería como un error de tipos en el sistema de módulos.</p>
<p>Ahora, vamos a crear una opción de un tipo customizado.</p>
<pre><code>nix-repl&gt; modulec = { options.output = lib.mkOption { type = lib.types.str; }; }
nix-repl&gt; result = lib.evalModules { modules = [ modulea moduleb modulec ]; }
nix-repl&gt; moduleb = { config, ... }: { config = { output = &quot;something&quot;; }; }
nix-repl&gt; result = lib.evalModules { modules = [ modulea moduleb modulec ]; }
nix-repl&gt; result.config
{ a = { ... }; output = &quot;something&quot;; }</code></pre>
<p>Ahora, deseamos que la configuración de <code>moduleb</code> solo se
habilite cuando se <q>encienda</q> <code>A</code>.</p>
<pre><code>nix-repl&gt; moduleb = { config, ... }: { config = lib.mkIf config.a.enable { output = &quot;something&quot;; }; }
nix-repl&gt; result = lib.evalModules { modules = [ modulea moduleb modulec ]; }
nix-repl&gt; result.config
{ a = { ... }; output = «error: error: The option `output&#39; is used but not defined.»; }</code></pre>
</section>
</section>
<section id="paquetes-instalados" class="level1">
<h1>Paquetes instalados</h1>
<pre><code>age
bash
starship
gnugrep
gh
tree-sitter
ffmpeg-full
noto-fonts-cjk-sans
noto-fonts-lgc-plus
xz
zstd
neovim
typst
typst-lsp
typstfmt
atuin
stylua
sqls
restic
ripgrep
go
zsh-autocomplete
zsh-completions
gopls
yaml-language-server
nix-zsh-completions
darwin.cctools
gnupg
gnumake
wget
macfuse-stubs
gawk
p7zip
ccls
texlive-combined-full-2023-final
texlab
tree-sitter-rst-grammar
tree
bash-completion
nix-bash-completions
open-pdf-sign
go-task
mpv
jetbrains-mono</code></pre>
<p>Otros que quizás me interesaría instalar:</p>
<pre><code>sqlite
lua
# luajit -- Conflicto con lua
font-jetbrains-mono-nerd-font
python3
python3-yt-dlp
pandoc
onlyoffice-bin -- quizás</code></pre>
<p>Quizás, la de las fuentes es mejor quitarla de Homebrew y usar
simplemente la de Nix.</p>
<p>Para entornos de C:</p>
<pre><code>gdb
valgrind</code></pre>
</section>
<!--</main>-->
</body>
</html>
