<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Carlos E. Tafur Egido" />
  <meta name="dcterms.date" content="2025-02-08" />
  <meta name="keywords" content="ciencias de la
computación, informática, tipografía, diseño, documentación, documentación
técnica" />
  <meta name="description" content="Documentación sobre Nix." />
  <title>Documentación sobre Nix</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "“" "”" "‘" "’"; }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #b3adad; background-color: #1e1e1e; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #e8ba9b; } /* Alert */
    code span.an { color: #627a62; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #a37979; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #a69974; } /* ControlFlow */
    code span.ch { color: #a37979; } /* Char */
    code span.cn { color: #a37979; font-weight: bold; } /* Constant */
    code span.co { color: #627a62; } /* Comment */
    code span.cv { color: #627a62; font-weight: bold; } /* CommentVar */
    code span.do { color: #627a62; } /* Documentation */
    code span.dt { color: #abab96; } /* DataType */
    code span.dv { color: #99998d; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #b3b378; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #627a62; font-weight: bold; } /* Information */
    code span.kw { color: #a69974; } /* Keyword */
    code span.op { color: #adad92; } /* Operator */
    code span.ot { color: #b3b378; } /* Other */
    code span.pp { color: #e8ba9b; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #a37979; } /* SpecialChar */
    code span.ss { color: #a17272; } /* SpecialString */
    code span.st { color: #a17272; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #a17272; } /* VerbatimString */
    code span.wa { color: #506350; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/variables.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/variables/manuales-comp-sci.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/base-mobile-first.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/tablas.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/tabla-contenidos.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/codigo.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/matematicas.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/desktop.css" />
  <nav id="nav">
    <!--<h2></h2>-->
    <ul id="menu">
    </ul>
  </nav>

  <!--<main>-->
  <input type="checkbox" id="toc-check" />
  <label id="toc-toggle" for="toc-check">ToC</label>
  <script src="/Users/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/javascript/breadcrumbs.js"></script>
  <script src="/Users/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/javascript/abre-cierra-nav-bar.js"></script>
  <script src="/Users/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/javascript/nameref.js"></script>
</head>
<body>
<div id="breadcrumb"></div>
<header id="title-block-header">
<h1 class="title">Documentación sobre Nix</h1>
<p class="author">Carlos E. Tafur Egido</p>
<p class="date">02/08/2025</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introducción" id="toc-introducción">Introducción</a></li>
<li><a href="#fuentes-de-información"
id="toc-fuentes-de-información">Fuentes de información</a></li>
<li><a href="#instalación" id="toc-instalación">Instalación</a>
<ul>
<li><a href="#flakes" id="toc-flakes"><em>Flakes</em> y el comando
<code>nix</code></a></li>
</ul></li>
<li><a href="#uso-como-gestor-de-paquetes"
id="toc-uso-como-gestor-de-paquetes">Uso como gestor de paquetes</a>
<ul>
<li><a href="#sin-flakes" id="toc-sin-flakes">Sin
<em>flakes</em></a></li>
<li><a href="#con-flakes" id="toc-con-flakes">Con
<em>flakes</em></a></li>
</ul></li>
<li><a href="#lenguaje-nix" id="toc-lenguaje-nix">Lenguaje Nix</a>
<ul>
<li><a href="#el-intérprete" id="toc-el-intérprete">El
intérprete</a></li>
<li><a href="#tipos-de-datos" id="toc-tipos-de-datos">Tipos de datos</a>
<ul>
<li><a href="#tipos-simples" id="toc-tipos-simples">Tipos
simples</a></li>
<li><a href="#conjuntos-de-atributos"
id="toc-conjuntos-de-atributos">Conjuntos de atributos</a></li>
<li><a href="#listas" id="toc-listas">Listas</a></li>
<li><a href="#funciones" id="toc-funciones">Funciones</a></li>
</ul></li>
<li><a href="#tipos-de-datos-1" id="toc-tipos-de-datos-1">Tipos de
datos</a></li>
<li><a href="#let-bindings" id="toc-let-bindings"><code>let</code>
<em>bindings</em></a></li>
<li><a href="#funciones-1" id="toc-funciones-1">Funciones</a></li>
<li><a href="#repl" id="toc-repl">REPL</a></li>
<li><a href="#derivaciones" id="toc-derivaciones">Derivaciones</a></li>
<li><a href="#el-sistema-module" id="toc-el-sistema-module">El sistema
<em>module</em></a></li>
</ul></li>
<li><a href="#paquetes-instalados" id="toc-paquetes-instalados">Paquetes
instalados</a></li>
</ul>
</nav>
<section id="introducción" class="level1">
<h1>Introducción</h1>
<p>Nix es una tecnología que ha comenzado a alcanzar popularidad en los
últimos años debido a que soluciona algunos de los problemas que se
tenían en el despliegue (<em>deployment</em>) de <em>software</em> y que
tecnologías modernas como los contenedores OCI (por ejemplo, los de
Docker), no llegaban a solucionar.</p>
<p>El gran problema con el despliegue se suele resumir en la frase <q>En
mi máquina funciona.</q>. Es decir, un desarrollador trabaja en un
entorno (<em>environment</em>) —su sistema— distinto al sistema en el
que terminará ejecutándose ese <em>software</em>. Esto produce muchos
problemas, y, de hecho, tradicionalmente se reservaba una franja de
tiempo del proyecto para la adaptación del <em>software</em> al entorno
nuevo.</p>
<p>La llegada de los contenedores OCI —siendo Docker la primera
herramienta que se popularizó de estos, sobre 2013— permite que el
desarrollador disponga en su máquina de un entorno muy similar al de la
máquina donde correrá ese <em>software</em>. Esto es verdad hasta cierto
punto. Por ejemplo, las imágenes de los contenedores OCI pueden tener
dependencias del sistema base que varían; por ejemplo,
<code>apt-get update</code> en diferentes momentos. Nix —sobretodo con
la funcionalidad [<em>flakes</em>][]— permite acercarse más a esto, ya
que este fija las versiones exactas de todas las dependencias.</p>
<p>Nix surgió como una idea que presentó Eelco Dolstra en <a
href="https://edolstra.github.io/pubs/phd-thesis.pdf">su tesis
doctoral</a> en la Universidad de Utretch en 2006. Pero, si somos
rigurosos, Dolstra creó tres cosas a las que se suele llamar <q>Nix</q>:
1) un lenguaje específico de dominio (<em>domain-specific language</em>
o DSL), de paradigma funcional puro muy inspirado en Haskell, 2) un
gestor de paquetes (<em>package manager</em>) como pueden ser Homebrew o
APT, y 3) una herramienta para la creación y gestión de entornos como
alternativa a cosas como los entornos <code>venv</code> del ecosistema
Python o a los contenedores Docker.</p>
<p>Como verá, los entornos de Nix tienen propiedades que los hacen mucho
mejores a sus alternativas. De hecho, podríamos considerar que el fin de
Nix es su uso para entornos. Los otros dos (el lenguaje y el gestor de
paquetes) no son más que componentes que sirven para tal fin.</p>
<p>Nix nos proporciona ciertas propiedades que son deseables en los
entornos:</p>
<ul>
<li>Reproducibilidad (<em>reproducibility</em>).</li>
<li>Determinismo (<em>determinism</em>). Es mejor que el de los
contenedores OCI, sobretodo cuando se habilita la funcionalidad
[<em>flakes</em>][].</li>
<li>Menor <q>basura</q> (<em>cruft</em>) es su sistema de archivos
(<em>filesystem</em>). Es decir, evita que este, tras instalaciones y
desinatalaciones, termine poblado de archivos de configuración
<q>huérfanos</q>, es decir, que ya no necesita.</li>
<li>Comodidad a la hora de desarrollar. Como explicamos al comienzo de
esta sección.</li>
</ul>
<p>En cuanto a lo malo, se podría incluir que Nix no es más seguro que
los contenedores OCI, ya que en principio no hacen un
<em>sandboxing</em> del entorno. Aun así, nada impide el uso de
contenedores OCI en un entorno Nix. Hay quien llega a afirmar que Nix
hace mejor esto que los gestores de contenedores, como Docker o
Podman.</p>
<p>Además de esto, existen ciertos proyectos relacionados con Nix, como
una distribución de Linux llamada NixOS que lleva la automatización de
Nix al extremo. En esta, puede tener especificado en código Nix, además
de todo el <em>software</em> que desee instalar en su sistema (gestión
de <em>software</em>), todos los ajustes de todo ese <em>software</em>.
Lo que es una maravilla es <q>levantar</q> de la nada un sistema justo
como lo desee, a partir de uno o varios archivos de texto; es decir, sin
necesidad de ejecutables.</p>
<p>También se tiene a <em>home manager</em>, para macOS. TKTK.</p>
<!--
De hecho, en mi caso particular, al igual que le sucede a muchos otros
usuarios de Nix, he pasado a instalar menos _software_ para todo el sistema
(_systemwide_) en favor de crear más frecuentemente entornos para propósitos
específicos. Por ejemplo, un _software_ que solía instalar de forma global
en mi sistema de uso personal es `yt-dlp`, que permite la descarga de vídeos
de sitios web. Ahora, lo que hago es tener un entorno en el que, cuando se
activa, se tiene de forma local dicha herramienta. Esto es muy propicio para
herramientas del tipo de `yt-dlp`, que en realidad son más bien bibliotecas
(_libraries_). TKTK.
-->
</section>
<section id="fuentes-de-información" class="level1">
<h1>Fuentes de información</h1>
<p>No es recomendable comenzar por la documentación oficial para
aprender lo básico sobre Nix, pues creo que es bastante inaccesible y no
han puesto gran cuidado en que tenga un enfoque pedagógico. No me lo
parece solo a mí; lo mismo ha comentado gente que sabe mucho más que yo
sobre Nix.</p>
<p>Personalmente, me gustó bastante la <a
href="https://www.youtube.com/watch?v=TsZte_9GfPE">conferencia</a> de un
empleado de ReplIt. Es fácil de entender. Para adentrarse un poco más en
el lenguaje Nix y las derivaciones, está muy bien <a
href="https://www.youtube.com/watch?v=5D3nUU1OVx8">un vídeo</a> en
YouTube de Surma. También está bien para adentrarse en el lenguaje Nix
<a href="https://www.youtube.com/watch?v=t8ydCYe9Y3M">un tutorial</a> en
YouTube de Jake Hamilton.</p>
<p>Para <a href="#uso-como-gestor-de-paquetes">su uso como sustituto de
Homebrew o de APT</a>, no es necesario aprender mucho sobre Nix, pero,
si desea sacarle el máximo partido, deberá adentrarse en el uso del
lenguaje Nix así como la forma en la que funciona Nix internamente en su
sistema.</p>
<p>La empresa Determinate Systems tiene también un buen tutorial de Nix,
titulado <a href="https://zero-to-nix.com/">Zero to Nix</a>.</p>
</section>
<section id="instalación" class="level1">
<h1>Instalación</h1>
<p>Además de la instalación tradicional de Nix, la que <a
href="https://nixos.org/download/">se explica en su web</a> oficial,
ahora existe la posibilidad de instalar una distribución de Nix (<em>Nix
distribution</em>) llamada Determinate Nix.</p>
<p>Lo que se hace en la instalación tradicional es descargar un
<em>script</em> de <em>shell</em> que se encarga de hacer la
instalación. En macOS no hay nada que decidir, pero en Linux se puede
hacer la instalación monousuario o la multiusuario. Se recomienda esta
última, que lo instalará como un demonio (<em>daemon</em>); por tanto,
como un <em>software</em> de tipo cliente-servidor.</p>
<p>Tal y como hemos dicho, existe también la posibilidad de instalar una
distribución de Nix. La más popular es <a
href="https://docs.determinate.systems/determinate-nix/">Determinate
Nix</a>, creada por la empresa <a
href="https://zero-to-nix.com/">Determinate Systems</a>, en la que
actualmente trabaja el propio Dolstra, el creador de Nix.</p>
<p>Entre las ventajas que tiene esta última están que es algo más cómoda
de instalar y de gestionar. También, se evitan los problemas que se
tienen con la otra en sistemas Linux con SELinux habilitado. Además,
trae habilitada de serie la funcionalidad [<em>flakes</em>][] y el
comando <code>nix</code>, aunque quizás sea preferible comenzar su
aprendizaje de Nix sin <em>flakes</em>, ya que esto supone otra
<q>capa</q> de conocimiento.</p>
<p>Para hacer la instalación mediante la distribución de Determinate
Systems, solo hay que seguir las explicaciones del repositorio <a
href="https://github.com/DeterminateSystems/nix-installer"><code>nix-installer</code></a></p>
<p>Esto activa el uso del comando <code>nix</code> y cambia también los
repositorios. En cuanto a los <em>flakes</em>, se suele usar con estos.
TKTK.</p>
<section id="flakes" class="level2">
<h2><em>Flakes</em> y el comando <code>nix</code></h2>
<p>Nix incorporó en 2021 una funcionalidad experimental llamada
<em>flakes</em> que supone un gran salto en el funcionamiento de este.
Con <em>flakes</em> tenemos a un Nix más determinista y lleva un paso
más allá la filosofía de Nix.</p>
<p>Por ejemplo, si no usa <em>flakes</em> los paquetes que tenga serán
de la versión que indique o TKTK.</p>
<p>El inconveniente de usar <em>flakes</em> es que para su uso requiere
de añadir una <q>capa</q> más de conocimiento. Por tanto, lo más
recomendable es que, antes de pasarse a usar Nix mediante la interfaz
<em>flakes</em>, aprenda a usar Nix del modo tradicional.</p>
<p>El uso de <em>flakes</em> suele venir asociado a lo que se suele
llamar <q>el comando <code>nix</code></q>, que no es más que una
modernización de los comandos de Nix. En la forma antigua, se suelen
usar comandos de la forma <code>nix-&lt;algo&gt;</code>, mientras que,
en la nueva (haciendo uso del comando <code>nix</code>), se usa un solo
comando, <code>nix</code>, junto con subcomandos. Por ejemplo,</p>
<pre><code>$ nix profile list</code></pre>
<p>que listaría los paquetes instalados mediante Nix, en lugar de</p>
<pre><code>$ nix-env -q</code></pre>
<p>Si ha instalado Nix mediante la distribución de Determinate Systems,
tendrá habilitados tanto los <em>flakes</em> como el comando
<code>nix</code>; no tendrá que hacer nada a este respecto. Sin embargo,
si ha hecho la instalación tradicional, deberá especificarlo con la
línea siguiente en el archivo de configuración de Nix:</p>
<pre><code>experimental-features = nix-command flakes</code></pre>
<p>Dicho archivo puede encontrarse en diversos sitios, según el sistema
operativo y el tipo de instalación (de Nix): de un solo usuario o de
todo el sistema (<em>systemwide</em>). En el primer caso, podría estar
en <em>~/.config/nix/nix.conf</em>, mientras que, en el segundo, en
<em>/etc/nix/nix.conf</em>. (Recuerde que la recomendada es la
instalación para todo el sistema.)</p>
<p>También, suelo especificar que se cree en el sistema el grupo de Nix,
llamado <code>nixbld</code>:</p>
<pre><code>build-users-group = nixbld</code></pre>
<p>Deberá añadir también a su usuario a ese grupo:</p>
<pre><code># usermod -aG nixbld &lt;usuario&gt;</code></pre>
<p>Por supuesto, estamos hablando de sistemas de tipo Unix, como, por
ejemplo, Linux y macOS. En Windows, para instalar Nix deberá hacer uso
de WSL2.</p>
</section>
</section>
<section id="uso-como-gestor-de-paquetes" class="level1">
<h1>Uso como gestor de paquetes</h1>
<p>Antes de pasar a hablar de entornos y del lenguaje Nix, veamos su uso
como un simple gestor de paquetes, es decir, como alternativa a cosas
como Homebrew o APT.</p>
<section id="sin-flakes" class="level2">
<h2>Sin <em>flakes</em></h2>
<p>Instalar un paquete.</p>
<p>Para instalar un paquete, se usa el comando</p>
<pre><code>$ nix-env -iA nixpkgs.&lt;paquete&gt;</code></pre>
<p>pero antes de esto deberá actualizar la base de datos con el
<em>software</em> en TKTK:</p>
<pre><code>$ nix-channel --update</code></pre>
<p>Eliminar un paquete.</p>
<pre><code>$ nix-env --uninstall &lt;paquete&gt;</code></pre>
<p>Actualizar un paquete.</p>
<pre><code>$ nix-env --upgrade &lt;paquete&gt;</code></pre>
<p>Si lo que desea es actualizar todos los paquetes que tenga instalados
(mediante Nix), se usa el mismo comando solo que con la bandera
<code>--all</code>, es decir,</p>
<pre><code>$ nix-env --upgrade --all</code></pre>
<p>Buscar paquetes.</p>
<p>En principio, en Nix sin <em>flakes</em> no se pueden buscar paquetes
de un modo sencillo desde la línea de comandos. Lo mejor es que los
busque en <a href="https://search.nixos.org/packages">la web
correspondiente</a>.</p>
<p>Mostrar los paquetes instalados (mediante Nix).</p>
<pre><code>$ nix-env -q</code></pre>
<p>Eliminar paquetes huérfanos.</p>
<p>Por su arquitectura, el <em>software</em> instalado en su sistema
mediante Nix puede llegar a ocupar mucho. Este se instala bajo el
directorio <em>/nix/store</em>, cosa que recibe el nombre de la
<em>tienda Nix</em> (<em>Nix store</em>). Para eliminar el
<em>software</em> que actualmente es innecesario, puede usar el comando
siguiente:</p>
<pre><code>$ nix-collect-garbage -d</code></pre>
</section>
<section id="con-flakes" class="level2">
<h2>Con <em>flakes</em></h2>
<p>Actualizar paquetes.</p>
<p>Si tiene <em>flakes</em>, no es necesario lanzar ningún comando para
actualizar paquetes, pues TKTK.</p>
<!--
Mencionas que no es necesario lanzar ningún comando para actualizar
paquetes. Esto puede ser confuso. Probablemente te refieres a que el
flake.lock fija las versiones, pero para actualizar las dependencias de los
flakes sí se necesita un comando como nix flake update. Sería bueno
aclararlo.
-->
<p>Instalar un paquete.</p>
<pre><code>$ nix profile install nixpkgs#&lt;paquete&gt;</code></pre>
<p>Buscar paquetes.</p>
<p>Si usa <em>flakes</em> sí puede buscar paquetes desde la línea de
comandos.</p>
<pre><code>$ nix search nixpkgs &quot;&lt;regex&gt;&quot;</code></pre>
<p>Mostrar paquetes instalados</p>
<pre><code>$ nix profile list</code></pre>
<p>Actualizar paquetes.</p>
<pre><code>$ nix profile upgrade --all</code></pre>
<p>Desinstalar un paquete</p>
<pre><code>$ nix profile remove &lt;paquete&gt;</code></pre>
</section>
</section>
<section id="lenguaje-nix" class="level1">
<h1>Lenguaje Nix</h1>
<p>El uso de Nix como gestor de paquetes no ha sido nunca el propósito
principal de sus creadores. Para sacar el máximo provecho de Nix debe
aprender a crear y gestionar entornos con este. Para esto, debe aprender
lo básico del lenguaje Nix.</p>
<p>Los dos videotutoriales que he seguido aquí son <a
href="https://www.youtube.com/watch?v=UgrwoAGSPOQ">el de Vimjoyer</a> y
el <a href="https://www.youtube.com/watch?v=t8ydCYe9Y3M">Nix From
Nothing #1</a>.</p>
<p>Más riguroso es <a
href="https://nixos.org/guides/nix-pills/04-basics-of-language.html">el
tutorial</a> sobre el lenguaje Nix en la documentación oficial de Nix.
También, <a href="https://nix.dev/tutorials/nix-language">el tutorial de
Nix.dev</a>. Además, se tiene como referencia <a
href="https://nixos.org/manual/nix/stable/language/">lo que explican</a>
en el manual oficial, que le dará un conocimiento más completo.</p>
<p>El lenguaje Nix, tal y como ya se ha dicho, se adhiere mucho al
paradigma funcional puro. Es bastante parecido a Haskell, por lo que si
ha programado en este tiene gran parte del <q>recorrido</q> hecho.</p>
<section id="el-intérprete" class="level2">
<h2>El intérprete</h2>
<p>Podríamos entrar al intérprete (también llamados REPL) de Nix con el
comando <code>nix repl</code>:</p>
<pre><code>$ nix repl
Nix 2.28.3
Type :? for help.
nix-repl&gt;</code></pre>
<p>Podríamos introducir expresiones como la siguiente y nos devuelve la
evaluación (<em>evaluation</em>) de la misma:</p>
<pre><code>nix-repl&gt; 9 + 9
18</code></pre>
<p>También podemos evaluar las expresiones almacenadas en un archivo.
Por ejemplo, si desde nuestro <em>shell</em> (salga del REPL) creamos un
archivo <em>expresion.nix</em> que contenga la expresión</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span> <span class="op">+</span> <span class="dv">9</span></span></code></pre></div>
<p>podemos evaluarla con el comando siguiente de su <em>shell</em>:</p>
<pre><code>$ nix-instantiate --eval expresion.nix
18</code></pre>
</section>
<section id="tipos-de-datos" class="level2">
<h2>Tipos de datos</h2>
<p>En cuanto a las características del tipado en Nix, hay que decir que
se trata de tipado fuerte (<em>strongly typed</em>), pero aun así no
cuenta con tipado estático, sino dinámico (<em>dynamic typed</em>).</p>
<section id="tipos-simples" class="level3">
<h3>Tipos simples</h3>
<!-- TODO De hecho, no sé si se pueden crear tipos propios. -->
<p>Cuenta con varios tipos de datos predefinidos (<em>built-in</em>,
también llamados <em>primitivos</em>). Los tipos de datos simples
(también llamados <em>atómicos</em>) son: entero (<em>integer</em>),</p>
<pre><code>nix-repl&gt; 7
7</code></pre>
<p>coma (o punto) flotante (<em>floating point</em>),</p>
<pre><code>nix-repl&gt; 7.1
7.1</code></pre>
<p>cadena (<em>string</em>),</p>
<pre><code>nix-repl&gt; &quot;cadena&quot;
&quot;cadena&quot;

nix-repl&gt; &#39;&#39;cadena&#39;&#39;
&quot;cadena&quot;</code></pre>
<p>ruta (<em>path</em>),</p>
<pre><code>nix-repl&gt; ./.
/Users/usuario</code></pre>
<p>buleano (<em>Boolean</em>),</p>
<pre><code>nix-repl&gt; true
true</code></pre>
<p>nulo (<em>null</em>),</p>
<pre><code>nix-repl&gt; null
null</code></pre>
<p>Quizás le llame la atención el tipo de datos ruta. Tiene sentido
debido al propósito de Nix.</p>
<!--
También es predefinido el tipo de datos lista (_list_), aunque este no es
simple. Un ejemplo de lista sería el siguiente:

```nix
[ "uno" "dos" "tres" ]
```

Veámosla en el REPL:

```
nix-repl> [ "uno" "dos" "tres" ]
[
  "uno"
  "dos"
  "tres"
]
```
-->
<p>Ahora, veamos los tipos de datos no simples; aquí es donde se pone
interesante la cosa.</p>
</section>
<section id="conjuntos-de-atributos" class="level3">
<h3>Conjuntos de atributos</h3>
<p>El tipo de datos predefinido no simple más interesante en Nix es el
<strong>conjunto de atributos</strong> (<em>attribute set</em>). Se
trata de algo parecido a los diccionarios de Python o los mapas de
<em>hash</em> en otros lenguajes. Un ejemplo sería el siguiente:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">one</span> <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">two</span> <span class="op">=</span> <span class="st">&quot;world&quot;</span><span class="op">;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">three</span> <span class="op">=</span> <span class="st">&quot;something&quot;</span><span class="op">;</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Veámoslo en el REPL:</p>
<pre><code>nix-repl&gt; { one = &quot;hello&quot;; two = &quot;world&quot;; three = &quot;something&quot;; }
{
  one = &quot;hello&quot;;
  three = &quot;something&quot;;
  two = &quot;world&quot;;
}</code></pre>
<p>Se podría decir que <q>existe</q> el tipo de datos conjunto
(<em>set</em>), al igual que en otros lenguajes; como Python, por
ejemplo. Este se indica con las llaves, <code>{ }</code>. En el último
ejemplo (el conjunto de atributos), los elementos que hay dentro,
separados por el signo de punto y coma, <code>;</code>, serían
<strong>atributos</strong> (<em>attributes</em>). Dije que
<q>existe</q>, entre comillas, el tipo conjunto porque en realidad en
Nix no podemos expresar un conjunto si no es en la estructura conjunto
de atributos.</p>
<p>Debe saber que, a veces, por comodidad, a los conjuntos de atributos
los llaman <em>conjuntos</em> (<em>sets</em>) a secas.</p>
<p>Haciendo una analogía con los diccionarios de Python, cada atributo
consta de una clave (<em>key</em>), cosa que en Nix llaman <em>nombre de
atributo</em> (<em>attribute name</em>), y un <em>valor</em>
(<em>value</em>).</p>
<p>Advierta que los conjuntos de atributos pueden ser heterogéneos:</p>
<pre><code>nix-repl&gt; { one = &quot;hello&quot;; two = &quot;world&quot;; three = 3; }
{
  one = &quot;hello&quot;;
  three = 3;
  two = &quot;world&quot;;
}</code></pre>
<p>También se permite el anidamiento (<em>nesting</em>) de conjuntos de
atributos,</p>
<pre><code>nix-repl&gt; { one = &quot;hello&quot;; two = &quot;world&quot;; three = &quot;something&quot;; x = { a = 1; b = true; }; }
{
  one = &quot;hello&quot;;
  three = &quot;something&quot;;
  two = &quot;world&quot;;
  x = { ... };
}</code></pre>
<p>Alternativamente, la anidación de conjuntos de atributos se puede
especificar mediante la notación con punto, como en el ejemplo
siguiente:</p>
<pre><code>nix-repl&gt; { one = &quot;hello&quot;; two = &quot;world&quot;; three = &quot;something&quot;; x.a = 1; x = { b = true; }; }
{
  one = &quot;hello&quot;;
  three = &quot;something&quot;;
  two = &quot;world&quot;;
  x = { ... };
}</code></pre>
<p>Ambos evaluarían al mismo conjunto de atributos.</p>
<p>Para tomar un valor de un conjunto de atributos, podemos usar también
la notación con punto:</p>
<pre><code>nix-repl&gt; { one = &quot;hello&quot;; two = &quot;world&quot;; }.one
&quot;hello&quot;</code></pre>
<p>Tras el punto, se indica el nombre del atributo del que queremos
obtener el valor.</p>
<p>Si se fija, hasta ahora únicamente hemos hecho uso de literales
(<em>literals</em>). Podemos también hacer uso de variables:</p>
<pre><code>nix-repl&gt; myvar = { one = &quot;hello&quot;; two = &quot;world&quot;; }

nix-repl&gt; myvar.one
&quot;hello&quot;</code></pre>
<p>Advierta que no hemos tenido que especificar el tipo de la
variable.</p>
<p>En cada archivo Nix se tiene una única expresión, por lo que lo
anterior no es algo que pueda encontrarse en su uso de Nix. Es así por
tratarse de un lenguaje funcional puro.</p>
<p>Si deseamos hacer uso de variables en un archivo Nix, tenemos las
<strong>expresiones <em>let-in</em></strong> (<em>let-in
expressions</em>). Por ejemplo,</p>
<pre><code>nix-repl&gt; let
              my-var = {
                  one = &quot;hello&quot;;
                  two = &quot;world&quot;;
              };
          in
              my-var.one
&quot;hello&quot;</code></pre>
<p>Esto mismo, en un archivo Nix seria</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">my-var</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">one</span> <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">two</span> <span class="op">=</span> <span class="st">&quot;world&quot;</span><span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    my<span class="op">-</span>var<span class="op">.</span>one</span></code></pre></div>
<p>que evaluaría a <code>"hello"</code>.</p>
<p>En la parte <em>let</em> se declaran las variables y, en la
<em>in</em>, se hace uso de estas. Por cierto, Nix tiene la propiedad de
evaluación perezosa (<em>lazy evaluation</em>).</p>
<p>También podemos hacer que una expresión <em>let</em> sea un valor en
un atributo (dentro de un conjunto de atributos):</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">x</span> <span class="op">=</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">a</span> <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">b</span> <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">y</span> <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="op">}.</span>x</span></code></pre></div>
<p>que evaluaría a <code>9</code>.</p>
<p>Opcionalmente, se podría añadir paréntesis (<code>( )</code>)
alrededor de la expresión <em>let</em>. Aunque no afecta al resultado,
se usa con el único propósito de hacer más legible el código.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    (<span class="va">x</span> <span class="op">=</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">a</span> <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">b</span> <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> a <span class="op">+</span> b)<span class="op">;</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">y</span> <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="op">}.</span>x</span></code></pre></div>
<p>Las expresiones <em>let</em> y las <em>in</em> son parseadas
recursivamente hasta que sean evaluadas todas las variables, lo cual
significa que incluso podemos usar variables en las expresiones de otras
variables.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    (<span class="va">x</span> <span class="op">=</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>            <span class="va">a</span> <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">b</span> <span class="op">=</span> a <span class="op">+</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> a <span class="op">+</span> b)<span class="op">;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">y</span> <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="op">}.</span>x</span></code></pre></div>
<!-- Por el minuto 4 hay cosas que no he copiado -->
<p>Advierta que se puede hacer uso de la interpolación de cadena
(<em>string interpolation</em>, también llamadas <em>string
templates</em>) en las expresiones <em>let-in</em>. Se marca con
<code>${}</code>.</p>
<pre><code>nix-repl&gt; let nombre = &quot;Carlos&quot;; in &quot;hola, ${nombre}&quot;
&quot;hola, Carlos&quot;</code></pre>
<p>En los conjuntos de atributos desearíamos poder hacer uso de la
recursión para referenciar variables entre ellas. Para hacer esto, se
debe hacer uso de la palabra clave <code>rec</code>, como en el ejemplo
siguiente:</p>
<pre><code>nix-repl&gt; { a = 5; b = a + 5; }
error: undefined variable &#39;a&#39;
       at «string»:1:14:
            1| { a = 5; b = a + 5; }
             |              ^

nix-repl&gt; rec { a = 5; b = a + 5; }
{
  a = 5;
  b = 10;
}</code></pre>
</section>
<section id="listas" class="level3">
<h3>Listas</h3>
<p>Otro tipo de datos predefinido no simple son las listas. Estas pueden
ser heterogéneas:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span> <span class="st">&quot;hello&quot;</span> <span class="dv">4</span> <span class="cn">true</span> <span class="op">]</span></span></code></pre></div>
<p>La separación de los elementos en la lista se marca con espacios.
Pueden ser uno o más. Los espacios entre los corchetes (que indican que
se trata de una lista) y los elementos de la lista no tiene por qué
hacerse con espacios entre ambos, pero se suele seguir la regla de
estilo de poner ahí un espacio.</p>
<p>Algo que se puede usar también en las listas es la palabra clave
<code>with</code>. Gracias a esta, tenemos una forma alternativa de
expresar una expresión <em>let-in</em>. Por ejemplo,</p>
<pre><code>nix-repl&gt; with { a = 5; b = 6; c = 7; }; [ &quot;hello&quot; 4 a b ]
[
  &quot;hello&quot;
  4
  5
  6
]</code></pre>
<p>que sería lo mismo que lo siguiente:</p>
<pre><code>nix-repl&gt; let a = 5; b = 6; c = 7; in [ &quot;hello&quot; 4 a b ]
[
  &quot;hello&quot;
  4
  5
  6
]</code></pre>
<p>La palabra clave <code>with</code> puede usarse en otras estructuras
distintas a las listas; por ejemplo, en conjuntos de atributos:</p>
<pre><code>nix-repl&gt; with { a = 5; b = 6; c = 7; }; { five = a; six = b; }
{
  five = 5;
  six = 6;
}</code></pre>
</section>
<section id="funciones" class="level3">
<h3>Funciones</h3>
<p>Ahora, pasemos a las funciones, ya que Nix es un lenguaje funcional
puro y, por tanto, son muy importantes. Veamos primero una función muy
sencilla:</p>
<pre><code>nix-repl&gt; my-func = a: a + 1

nix-repl&gt; my-func 3
4</code></pre>
<p>Lo primero es la definición (<em>definition</em>) y después ponemos
la llamada (<em>call</em>) o invocación de la misma.</p>
<p>Nix tiene funciones anónimas (<em>anonymous functions</em>, también
llamada <em>funciones lambda</em>, <em>lambda functions</em>). Un
ejemplo sería la anterior:</p>
<pre><code>a: a + 1</code></pre>
<p>La sintaxis es muy sencilla. Se pone el argumento seguido del signo
de dos puntos, <code>:</code>, y a la derecha se pone el cuerpo
(<em>body</em>) de la misma.</p>
<p>Estas pueden usarse como valores que se pueden asignar a variables,
como se hace en</p>
<pre><code>my-func = a: a + 1</code></pre>
<p>Esta funcionalidad suele recibir el nombre de <em>funciones de
primera clase</em> (<em>first-class functions</em>).</p>
<p>Para tener lo anterior como una sola expresión (y poder usarla como
archivo Nix), la incluiríamos en una expresión <em>let-in</em>:</p>
<pre><code>nix-repl&gt; let my-func = a: a + 1; in my-func 3
4</code></pre>
<p>Al respecto de los argumentos de las funciones, en Nix existe la
restricción de que este solo puede ser uno. Esto no es un problema ya
que puede hacer lo que en programación funcional llaman
<em>currying</em>, que consiste en especificar las funciones anidándolas
unas dentro de otras. Por ejemplo,</p>
<pre><code>nix-repl&gt; let my-func = a: b: (a + 1) * b; in my-func 3 7
28</code></pre>
<p>Como estamos haciendo anidación, si pasamos un solo argumento a esa
función tendremos que la salida será una función solo que con un
argumento menos, que será sustituido por un valor en concreto. Por
ejemplo,</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">my-func</span> <span class="op">=</span> <span class="va">a</span><span class="op">:</span> <span class="va">b</span><span class="op">:</span> <span class="op">(</span>a <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> b<span class="op">;</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">my-func-unwrapped</span> <span class="op">=</span> my<span class="op">-</span>func <span class="dv">3</span><span class="op">;</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    my<span class="op">-</span>func<span class="op">-</span>unwrapped <span class="dv">7</span></span></code></pre></div>
<p>que evalúa a <code>28</code>. Si se fija, aquí la función
<code>my-func-unwrapped</code> tiene como valor a la función</p>
<pre><code>b: (3 + 1) * b</code></pre>
<p>Metafóricamente, sería como pelar una cebolla. Como ve, aunque sirve
para tener varios argumentos, no llega a ser lo mismo exactamente.
Alternativamente, existe otra forma de especificar varios argumentos,
que se comporta de un modo más parecido a lo que deseamos. Simplemente
consiste en usar como parámetro o argumento un conjunto de
atributos.</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">my-func</span> <span class="op">=</span> <span class="op">{</span> <span class="va">a</span><span class="op">,</span> <span class="va">b</span><span class="op">,</span> <span class="op">}</span>: a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    my<span class="op">-</span>func <span class="op">{</span> <span class="va">a</span> <span class="op">=</span> <span class="dv">9</span><span class="op">;</span> <span class="va">b</span> <span class="op">=</span> <span class="dv">15</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que evalúa a <code>24</code>. Advierta que hemos puesto una
<em>trailing comma</em> en el conjunto de atributos que usamos como
parámetro de <code>my-func</code>. Esto es opcional, pero es una regla
de estilo que se suele usar en Nix.</p>
<!-- TODO Inherit -->
<p>Las funciones en Nix cuentan también con valores predefinidos para
los argumentos. Para esto, se usa el signo de cierre de interrogación,
<code>?</code>.</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">my-func</span> <span class="op">=</span> <span class="op">{</span> <span class="va">a</span> <span class="op">?</span> <span class="dv">100</span><span class="op">,</span> <span class="va">b</span><span class="op">,</span> <span class="op">}</span>: a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    my<span class="op">-</span>func <span class="op">{</span> <span class="va">b</span> <span class="op">=</span> <span class="dv">15</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que evalúa a <code>115</code>.</p>
<p>Como sucede en otros lenguajes, se usa el valor predefinido
únicamente si no se pasa un valor de forma explícita al parámetro.</p>
<p>Si añadimos como argumento un signo de tres puntos (como los puntos
suspensivos, <em>elipsis</em>), <code>...</code>, cualquier atributo
adicional, a partir del segundo, será ignorado. Pero si también añadimos
a la derecha de ese argumento (el conjunto de atributos) el símbolo
arroba, <code>@</code>, seguido de algún nombre, TKTK.</p>
<!-- Volver a esto. Minuto 7:30 -->
<div class="sourceCode" id="cb55"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">my-func</span> <span class="op">=</span> <span class="op">{</span> <span class="va">a</span> <span class="op">?</span> <span class="dv">100</span><span class="op">,</span> <span class="va">b</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>@<span class="va">args</span><span class="op">:</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> args<span class="op">.</span>c <span class="kw">then</span> a <span class="kw">else</span> b<span class="op">;</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    my<span class="op">-</span>func <span class="op">{</span> <span class="va">b</span> <span class="op">=</span> <span class="dv">15</span><span class="op">;</span> <span class="va">c</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que evalúa a <code>100</code>.</p>
<!-- Segundo tutorial. A integrar con el anterior. -->
</section>
</section>
<section id="tipos-de-datos-1" class="level2">
<h2>Tipos de datos</h2>
<p>La estructura de datos principal de Nix es la que se conoce como
<em>conjunto de atributos</em> (<em>attributes set</em>), que sería en
cierto modo parecido a los diccionarios de Python (tiene muchos nombres;
además de estos, tabla <em>hash</em>, arreglo asociativo, mapas, etc.).
Tiene una sintaxis muy parecida a la del formato JSON.</p>
<p>También, hay que tener en cuenta que, ya que se adhiere bastante al
paradigma funcional, en Nix lo que se maneja son expresiones
(<em>expressions</em>); no afirmaciones (<em>statements</em>). Esto
permite al lenguaje prescindir del signo de punto y coma
(<code>;</code>, <em>semicolon</em>) al final. En cualquier caso, por
razones de expresividad, se ha dado otro uso a dicho símbolo;
concretamente, se usa para separar los distintos elementos dentro de un
conjunto de atributos.</p>
<p>Lo siguiente sería un literal de un conjunto de atributos. Por
ejemplo,</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">name1</span> <span class="op">=</span> <span class="st">&quot;value1&quot;</span><span class="op">;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">name2</span> <span class="op">=</span> <span class="st">&quot;value2&quot;</span><span class="op">;</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Tal y como hemos dicho, sería equivalente a un diccionario.</p>
<p>Si en su instalación de Nix tiene activado <em>flakes</em>, si
introduce lo anterior en un archivo como, por ejemplo,
<em>example.nix</em>, podemos evaluar ese conjunto de atributos con el
comando siguiente:</p>
<pre><code>$ nix eval --file example.nix
{ name1 = &quot;value1&quot;; name2 = &quot;value2&quot;; }</code></pre>
<p>El uso del punto y coma en los elementos de un conjunto de atributos
es obligatorio, incluso en el último de estos (de los elementos).</p>
<p>Otro tipo de dato estructurado que se tiene son las listas
(<em>lists</em>). Serían lo mismo que las listas en Python (mutabilidad?
mejor, las tuplas?). TKTK. Un literal de lista sería, por ejemplo,</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="op">]</span></span></code></pre></div>
<p>El espacio o nuevo renglón es el que sirve para delimitar los
elementos en la lista. La anterior sería igual a la siguiente:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="op">]</span></span></code></pre></div>
<p>Aunque se suele usar como regla de estilo dejar un espacio entre los
delimitadores y los elementos en su interior, este lo podríamos eliminar
si lo deseáramos:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span><span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span><span class="op">]</span></span></code></pre></div>
</section>
<section id="let-bindings" class="level2">
<h2><code>let</code> <em>bindings</em></h2>
<p>Aunque se tenga una expresión declarativa, se pueden especificar
valores de variables en esta, tal y como se hace, por ejemplo, en las
<em>list comprehensions</em> de Python. En Nix sucede algo similar. Para
esto se usan los <code>let</code> <em>bindings</em>. Por ejemplo,</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">myNumber</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    myNumber <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<p>Ojo con el punto y coma antes del <code>in</code>. Al ser un conjunto
de atributos lo que introducimos dentro de <code>let</code>, debrá tener
punto y coma cada uno de los elementos ahí. Lo que hay tras
<code>in</code> es una expresión que hace uso de ese conjunto de
atributos.</p>
<pre><code>$ nix eval --file 01.nix
43</code></pre>
<p>Como ve, sigue siendo una expresión pero esta vez esta tiene en
cuenta el valor de la variable <code>myNumber</code>.</p>
<p>Lo considero en realidad una expresión porque lo importante es lo que
va tras la palabra clave <code>in</code>. Lo que va entre
<code>let</code> e <code>in</code> es simplemente para hacer a la
expresión consciente de los valores de ciertas variables. En cualquier
caso, ya no estamos en un paradigma funcional puro; bueno, eso depende
de cómo se considere TKTK.</p>
<p>En cualquier caso, esas variables están confinadas a esa expresión,
es decir, no tenemos variables globales y, por tanto, no se puede
afirmar que el programa ejecutándose pase por estados diversos.</p>
</section>
<section id="funciones-1" class="level2">
<h2>Funciones</h2>
<p>Nix cuenta también, evidentemente, con funciones. Por ejemplo, así se
definiría y se invocaría una función que decidimos llamar
<code>greet()</code>.</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">greet</span> <span class="op">=</span> <span class="va">name</span><span class="op">:</span> <span class="st">&quot;Hello, </span><span class="sc">${</span>name<span class="sc">}</span><span class="st">!&quot;</span><span class="op">;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    greet <span class="st">&quot;Carlos&quot;</span></span></code></pre></div>
<p>Como ve, la función se define asignando una definición de función
anónima (<em>anonymous function</em>; a estas también las suelen llamar
<em>funciones lambda</em>, <em>lambda functions</em>) a una variable (en
este caso, <code>greet</code>), y esto se hace dentro de la parte
<code>let</code> de un <code>let</code> <em>binding</em>.</p>
<p>En la definición de la función, lo primero que se pone son los
parámetros (o parámetros formales). A la derecha de estos, un signo de
dos puntos (<code>:</code>, <em>colon</em>), y a su derecha, la propia
definición de la función; o su firma (<em>signature</em>), se podría
decir también.</p>
<p>En la parte <code>in</code>, se puede invocar la función, con los
argumentos (o parámetros reales) que deseemos. En este caso, el
argumento es el literal de cadena <code>Carlos</code>. Las comillas
sirven para delimitar al literal de cadena y, en este caso, no forman
parte del mismo; al igual que suele suceder con la mayoría de lenguajes
de programación.</p>
<p>La sintaxis suele evitar el uso de signos de llaves
(<code>{ }</code>) y paréntesis (<code>()</code>). También, como ve, se
hace interpolación de cadena (<em>string interpolation</em>, o plantilla
de cadena, <em>template string</em>) en los literales de cadena, al
igual que en tantos otros lenguajes. En este caso, tiene la forma
<code>${&lt;var&gt;}</code> donde <code>&lt;var&gt;</code> será la
variable de la que se tomará el valor para insertar en esa parte de la
cadena.</p>
<p>Al evaluar la expresión <code>let-in</code> anterior, dará como
resultado</p>
<pre><code>$ Hello, Carlos!</code></pre>
<p>como es evidente.</p>
<p>Si deseamos una función que tenga más de un parámetro de entrada, se
puede usa lo que en programación funcional llaman el <em>currying</em>,
es decir, hacer uso de una función dentro de otra.</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">greet</span> <span class="op">=</span> <span class="va">greeting</span><span class="op">:</span> <span class="va">name</span><span class="op">:</span> <span class="st">&quot;</span><span class="sc">${</span>greeting<span class="sc">}</span><span class="st">, </span><span class="sc">${</span>name<span class="sc">}</span><span class="st">!&quot;</span><span class="op">;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    greet <span class="st">&quot;Howdy&quot;</span> <span class="st">&quot;Carlos&quot;</span></span></code></pre></div>
<p>que devolverá</p>
<pre><code>$ Howdy, Carlos!</code></pre>
<p>Como ve, cuando se dan varios argumentos a una llamada de una
función, estos se separan mediante espacio.</p>
<p>Ahora, vamos a mezclar las funciones con conjuntos de atributos.</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="va">secret</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mySuperSecretValue</span> <span class="op">=</span> secret<span class="op">;</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="st">&quot;abcd&quot;</span></span></code></pre></div>
<p>que daría</p>
<pre><code>$ nix eval --file example.nix
{ mySuperSecretValue = &quot;abcd&quot;; }</code></pre>
<p>En este caso, la definición de la función es básicamente un conjunto
de atributos, como puede ver. Por tanto, lo que devuelve la función será
eso mismo.</p>
<p>Por cierto, de momento, como verá, estamos haciendo uso de argumentos
posicionales en las funciones. Ahora, vamos a ver cómo se haría uso de
argumentos nombrados.</p>
<p>También, se le podría pasar un conjunto de atributos como argumento a
la función.</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="va">secret</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mySuperSecretValue</span> <span class="op">=</span> secret<span class="op">;</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que daría</p>
<pre><code>$ nix eval --file example.nix
{ mySuperSecretValue = { key = &quot;my_secret&quot;; value = &quot;super-secret&quot;; }; }</code></pre>
<p>Ojo con el punto y coma tras <code>"super-secret"</code>. En
realidad, aquí no hemos hecho nada, es decir, este ejemplo no tiene
ningún sentido.</p>
<p>Pero quizás no era eso lo que deseábamos hacer, sino lo
siguiente:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mySuperSecretValue</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ mySuperSecretValue = &quot;super-secret&quot;; }</code></pre>
<p>Como ve, solo muestra el atributo al que se le da hado un valor. El
otro, al no haber recibido ningún valor, no lo muestra, pues, en la
definición de la función, no se da ningún uso al parámetro
<code>key</code>.</p>
<p>¿Pero cómo podríamos modificar esta función para que sí que haga uso
del parámetro <code>key</code> en la clave del conjunto de atributos? Es
muy sencillo; no hay más que usar la interpolación de cadena:</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;</span><span class="sc">${</span>key<span class="sc">}</span><span class="st">&quot;</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ my_secret = &quot;super-secret&quot;; }</code></pre>
<p>Podríamos haber puesto la clave sin comillas y también sería
válido.</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>        <span class="sc">${</span>key<span class="sc">}</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="va">in</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> { <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ my_secret = &quot;super-secret&quot;; }</code></pre>
<p>Si en la definición de la función solo se hubiera especificado el
parámetro <code>value</code> y, luego, en la llamada, se ponen ambos,
nos dará un error.</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mySuperSecretValue</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que daría</p>
<pre><code>❯ nix eval --file example.nix
error: &#39;makeSecret&#39; at /Users/ctafur/temp/nix/nix-from-nothing-tuto/dos/example.nix:2:18 called with unexpected argument &#39;key&#39;

       at /Users/ctafur/temp/nix/nix-from-nothing-tuto/dos/example.nix:6:5:

            5| in
            6|     makeSecret { key = &quot;my_secret&quot;; value = &quot;super-secret&quot;; }
             |     ^
            7|
(use &#39;--show-trace&#39; to show detailed location information)</code></pre>
<p>Si deseamos dejar abierta la posibilidad de que se pueda llamar a
otros argumentos no especificados en la definición de una función, se
puede usar la notación de elipsis (<em>ellipsis</em>): <code>...</code>,
para indicarlo.</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">value</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mySuperSecretValue</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ mySuperSecretValue = &quot;super-secret&quot;; }</code></pre>
<p>Es decir, tampoco hace uso del parámetro <code>key</code>, pero esta
vez no da error.</p>
<p>Advierta que, en el literal de conjunto de atributos que se usa en la
definición de la función, las variables en las claves, para ser
sustituidas por su valor, deben usar la notación de interpolación de
cadena, mientras que con los valores no sucede esto. Es decir, lo
siguiente</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">key</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>daría</p>
<pre><code>$ nix eval --file example.nix
{ key = &quot;super-secret&quot;; }</code></pre>
<p>que no es lo que deseábamos en este caso.</p>
<p>También, se podría hacer más dinámico:</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;user-key:</span><span class="sc">${</span>key<span class="sc">}</span><span class="st">&quot;</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ &quot;user-key:my_secret&quot; = &quot;super-secret&quot;; }</code></pre>
<p>Si queremos hacer lo siguiente:</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">value</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>se puede hacer de forma abreviada usando el enunciado
<code>inherit</code>:</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">makeSecret</span> <span class="op">=</span> <span class="op">{</span> <span class="va">key</span><span class="op">,</span> <span class="va">value</span> <span class="op">}</span>: <span class="op">{</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">inherit</span> <span class="va">value</span><span class="op">;</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    makeSecret <span class="op">{</span> <span class="va">key</span> <span class="op">=</span> <span class="st">&quot;my_secret&quot;</span><span class="op">;</span> <span class="va">value</span> <span class="op">=</span> <span class="st">&quot;super-secret&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>En ambos casos, se tendría como resultado</p>
<pre><code>$ nix eval --file example.nix
{ value = &quot;super-secret&quot;; }</code></pre>
<p>Imagino que el uso que se da a <code>inherit</code> será para hacer
pruebas sobre los estados de las variables, al igual que en Python se
hace con <code>f"variable="</code>.</p>
<p>También, se puede tener una función dentro de un conjunto de
atributos. La forma de acceder a este es mediante la notación punto.</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">conj_atrib</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">greet</span> <span class="op">=</span> <span class="va">greeting</span><span class="op">:</span> <span class="va">name</span><span class="op">:</span> <span class="st">&quot;</span><span class="sc">${</span>greeting<span class="sc">}</span><span class="st">, </span><span class="sc">${</span>name<span class="sc">}</span><span class="st">!&quot;</span><span class="op">;</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>    conj_atrib<span class="op">.</span>greet <span class="st">&quot;Howdy&quot;</span> <span class="st">&quot;Carlos&quot;</span></span></code></pre></div>
<p>TKTK.</p>
<p>También, debe saber que los comentarios son el símbolo <code>#</code>
para comentar hasta final de línea, y, <code>/*</code> y
<code>*/</code>, para abrir y cerrar, respectivamente, un comentario
multilínea.</p>
<!-- --------------------------------------------------------------- -->
<p>Llegados a este punto, básicamente hemos visto lo básico del lenguaje
Nix. Lo natural sería que el paso siguiente consistiera en integrar este
conocimiento con Nixpkgs, que son los paquetes junto con una serie de
fuciones. TKTK. Entre las cosas que haremos con Nixpkgs se encuentran
crear <em>helper functions</em> para mapas (<em>maps</em>), para filtros
(<em>filters</em>), etc.</p>
<p>Vamos a ver primero cómo se importan otros archivos de Nix.</p>
<p>Creamos el archivo <em>other-file.nix</em> con el contenido
siguiente:</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">greet</span> <span class="op">=</span> <span class="va">name</span><span class="op">:</span> <span class="st">&quot;Hello, </span><span class="sc">${</span>name<span class="sc">}</span><span class="st">!&quot;</span><span class="op">;</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Como ve, lo único que contiene es un conjunto de atributos cuyo único
elemento tiene por clave la cadena <code>"greet"</code> y, por valor,
una función anónima.</p>
<p>Ahora, vamos a crear otro archivo Nix, que llamaremos
<em>example.nix</em>, desde el que cargaremos el anterior archivo Nix,
<em>other-file.nix</em>. En <em>example.nix</em>, incluiremos lo
siguiente:</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">myLibrary</span> <span class="op">=</span> <span class="bu">import</span> <span class="ss">./other-file.nix</span><span class="op">;</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    myLibrary</span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
{ greet = &lt;LAMBDA&gt;; }</code></pre>
<p>En <em>example.nix</em> se la incluido, dentro de un <code>let</code>
<em>binding</em>, una importación del contenido de otro archivo Nix;
concretamente, de <em>other-file.nix</em>. El resultado de evaluar
<em>example.nix</em> es el esperado. En la información que nos da la
evaluación, la parte <code>&lt;LAMBDA&gt;</code> indica una función
anónima, pero sin especificar el contenido de esta. En cualquier caso,
la forma de invocarla es usar la clave asociada a la misma en la tabla,
es decir, <code>greet</code>. Pero ese atributo está dentro del conjunto
de atributos <code>myLibrary</code>, por lo que deberá llamar al
<code>greet</code> de <code>myLibrary</code>, cosa que puede hacer
usando el operador punto, tal y como se explicó antes.</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">myLibrary</span> <span class="op">=</span> <span class="bu">import</span> <span class="ss">./other-file.nix</span><span class="op">;</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    myLibrary<span class="op">.</span>greet <span class="st">&quot;Carlos&quot;</span></span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
&quot;Hello, Carlos!&quot;</code></pre>
<p>Esto mismo se puede hacer con los paquetes Nix.</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt;<span class="op">;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    pkgs</span></code></pre></div>
<p>que da</p>
<pre><code>$ nix eval --file example.nix
&lt;LAMBDA&gt;</code></pre>
<p>Como es una función (ya que pone <code>&lt;LAMBDA&gt;</code>, se
debería especificar algún parámetro, o varios de estos en un conjunto de
atributos. En realidad, <code>&lt;nixpkgs&gt;</code> es una función que
a su vez contiene muchas cosas a distintos niveles de anidamiento:
funciones y conjuntos de atributos, principalmente.</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{};</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    pkgs<span class="op">.</span>lib</span></code></pre></div>
<p>Esto nos mostrará todo lo que hay en el atributo <code>lib</code>
dentro de la lista de paquetes (<code>nixpkgs</code>). La salida es
bastante grande. Tenga cuidado de no intentar llamar a
<code>pkgs</code>, que llamaría a todos los paquetes. Lo hice, al seguir
este tutorial, y tuve que terminar reiniciando el computador, ya que son
muchos los paquetes incluidos actualmente.</p>
<p>Con <code>&lt;nixpkgs&gt;</code>, lo que hemos hecho es usar esa
biblioteca tomada de nuestro entorno, es decir, de la de nuestra
instalación de Nix. Se podría haber optado, alternativamente, a tomarla
de su repositorio en GitHub, por ejemplo, o de algún otro sitio,
especificando la URL que correspondiera.</p>
<p>Con el comando siguiente, se puede consultar de dónde lo toma su
instalación local:</p>
<pre><code>$ nix-channel --list
nixpkgs https://nixos.org/channels/nixpkgs-unstable</code></pre>
</section>
<section id="repl" class="level2">
<h2>REPL</h2>
<p>Una forma bastante cómoda de hacer pruebas con la biblioteca
<code>nixpkgs</code> es desde el REPL de Nix. Si tiene activado
<em>flakes</em>, se entra con</p>
<pre><code>$ nix repl
nix-repl&gt;</code></pre>
<p>Una diferencia con el lenguaje en los archivos es que en el REPL no
tiene que terminar con punto y coma. También, se pueden asignar valores
a variables sin usar <code>let</code>-<code>in</code>.</p>
<p>Tiene autocompletado, por lo que puede ir viendo los elementos de las
distintas bibliotecas.</p>
<pre><code>nix-repl&gt; pkgs = import &lt;nixpkgs&gt; {}
nix-repl&gt; pkgs.lib.</code></pre>
<p>Si ahí, sin pulsar <kbd>Intro</kbd>, pulsa <kbd>Tab</kbd> para hacer
<em>tab-completion</em>, se mostrará todo lo que hay bajo el conjunto de
atributos <code>lib</code> de <code>nixpkgs</code>.</p>
<p>Además de los distintos elementos de <code>nixpkgs</code>, nuestra
instalación trae siempre ciertos elementos de serie. A esto los llaman
<em>builtins</em>. Puede consultarlos también:</p>
<pre><code>nix-repl&gt; builtins.</code></pre>
<p>y pulse <kbd>Tab</kbd>. Por ejemplo, tenemos la función
<code>derivation</code> dentro de <code>builtins</code>, a la que podemo
hacer alusión con <code>builtins.derivation</code>.</p>
<pre><code>nix-repl&gt; builtins.derivation
«lambda @ /builtin/derivation.nix:5:1»</code></pre>
<p>Como vemos, es una función, ya que pone <code>lambda</code>. Esta
función tiene varios argumentos obligatorios. Si tratamos de invocarla
sin esos argumentos,</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="bu">builtins</span><span class="op">.</span>derivation <span class="op">{}</span></span></code></pre></div>
<p>nos dará un error.</p>
<pre><code>$ nix eval --file example.nix
error:
       … while evaluating the attribute &#39;outPath&#39;

         at /builtin/derivation.nix:19:9: (source not available)

       … while calling the &#39;getAttr&#39; builtin

         at /builtin/derivation.nix:19:19: (source not available)

       (stack trace truncated; use &#39;--show-trace&#39; to show the full trace)

       error: attribute &#39;name&#39; missing</code></pre>
<p>Vamos a ver los argumentos:</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="bu">builtins</span><span class="op">.</span>derivation <span class="op">{</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-derivation&quot;</span><span class="op">;</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="derivaciones" class="level2">
<h2>Derivaciones</h2>
<p>Las <em>derivaciones</em> (<em>derivations</em>) son las unidades
fundamentales para la construcción (<em>building</em>) y empaquetamiento
(<em>packaging</em>) del <em>software</em>. Una derivación es una
especificación de un proceso de construcción; no la salida de la
construcción. Describe todo lo que se necesita para crear un paquete,
asegurándose de que las construcciones son reproducibles y aisladas.</p>
<!-- El lenguaje Nix se creó con el propósito de escribir derivaciones -->
<p>¿Qué hay dentro de una derivación? Una derivación es básicamente una
<q>receta</q> escrita en el lenguaje Nix. Es un conjunto de atributos
—la estructura de datos básica de Nix, que no es más que una colección
de pares clave-valor— que contiene toda la información necesaria para
que el gestor de paquetes Nix construya un paquete de <em>software</em>.
Entre las claves de los atributos se encuentran las siguientes:</p>
<ul>
<li><code>builder</code>: El programa que realiza la construcción. A
menudo se trata de un <em>script</em> de <em>shell</em>.</li>
<li><code>args</code>: Lista con los argumentos que se pasan al comando
de <code>builder</code>.</li>
<li><code>name</code>: Un nombre único para el paquete resultante; por
ejemplo, <code>hello-2.12.1</code>.</li>
<li><code>src</code>: El código fuente (<em>source code</em>) para
construir. A menudo se obtiene (<em>fetch</em>) de una URL o una ruta
local (<em>local path</em>).</li>
<li><code>system</code>: La arquitectura para la que se está
construyendo el paquete; por ejemplo, <code>x86_64-linux</code>.</li>
<li><code>buildInputs</code>: Una lista de otras derivaciones
(dependencias) que son requeridas para construir el paquete.</li>
<li><code>propagatedBuildInputs</code>: Dependencias que se requieren no
solo para construir el paquete sino también para ejecutarlo.</li>
</ul>
<p>Cuando se le pide a Nix que construya un paquete (por ejemplo,
mediante el uso del comando <code>nix-build</code>), este busca el
archivo de la derivación para dicho paquete. Este archivo contiene el
<em>blueprint</em> completo para la construcción. Entonces Nix</p>
<ul>
<li><p>Resuelve las dependencias. Comprueba primero si todas las
<code>buildInputs</code> y otras dependencias se encuentran ya
construidas en la tienda Nix (<em>Nix store</em>). Si no es así, las
construye primero.</p></li>
<li><p>Crea un entorno aislado (<em>sandboxed environment</em>). Nix
crea un entorno hermético para el proceso de construcción. Este
<em>sandbox</em> se asegura de que el <em>build</em> solo puede acceder
al código y las dependencias especificadas. No puede ver o user nada más
del sistema, como bibliotecas o herramientas instaladas fuera de la
tienda Nix.</p></li>
<li><p>Ejecuta el <em>builder</em>. Nix ejecuta el <em>script</em> de
construcción con los argumentos especificados dentro del
<em>sandbox</em>. Este <em>script</em> normalmente realiza los pasos que
tradicionalmente se usan para compilar código fuente en sistemas de tipo
Unix, es decir, <code>configure</code>, <code>make</code> y
<code>make install</code>.</p></li>
<li><p>Almacena la salida. El paquete una vez construido es almacenado
en la tienda Nix, un directorio especial, normalmente con la ruta
<em>/nix/store</em>. Cada paquete tiene una ruta única y accesible por
el contenido; por ejemplo,
<em>/nix/store/1y9b6348hgzb…-hello-2.12.1</em>.La primera parte del
nombre del archivo es un <em>hash</em> de todos sus <em>inputs</em> y de
la receta de construcción.</p></li>
</ul>
<hr />
<p>Dentro de los elementos que vienen de serie en nuestra instalación de
Nix, que se encuentran en el conjunto de atributos
<code>builtins</code>, se tiene la función <code>derivation</code>.
Sabemos que se trata de una función porque, si la invocamos desde el
REPL, muestra lo siguiente:</p>
<pre><code>nix-repl&gt; builtins.derivation
«lambda @ /builtin/derivation.nix:5:1»</code></pre>
<p>Como ve, nos referimos a esta empleando la notación punto:
<code>builtins.derivation</code>. Aun así, esta no se puede invocar sin
especificar los valores para ciertos parámetros.</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="bu">builtins</span><span class="op">.</span>derivation <span class="op">{</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-derivation&quot;</span><span class="op">;</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;x86_64-darwin&quot;</span><span class="op">;</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">builder</span> <span class="op">=</span> <span class="st">&quot;/bin/sh&quot;</span><span class="op">;</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">args</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;-c&quot;</span> <span class="st">&quot;echo Hello &gt; $out&quot;</span> <span class="op">];</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Estos parámetros son <code>name</code>, que es el nombre que queramos
que tenga esta. También, <code>system</code>, donde se debe especificar
el nombre del sistema sobre el que se podrá ejecutar. Se podría
consultar en el REPL del modo siguiente:</p>
<pre><code>nix-repl&gt; builtins.attrNames pkgs.lib.platforms</code></pre>
<p>Puede ser, por ejemplo, para Linux en arquitectura x86 de 64 bits,
<code>x86_64-linux</code>.</p>
<p>También es obligatorio el parámetro <code>builder</code>, que es el
programa del que se va a crear la derivación. Como parámetro opcional,
complementando al <em>software</em> que se incluya en
<code>builder</code>, se tiene el parámetro <code>args</code>, que
especifica una lista con los argumentos que deseamos que tenga dicho
comando.</p>
<p>En este ejemplo, se ha especificado que se construya el
<em>software</em> que se encuentra en el archivo <em>/bin/sh</em>.
Además, que se le pasen como argumentos <code>-c</code> y
<code>echo Hello &gt; $out</code>, cosa que quiere decir que se muestre
en la salida estándar de ese <em>shell</em> (_/bin/<em>sh</em>) la
cadena <code>Hello</code>. Advierta que <code>$out</code> tiene un
significado especial en Nix. Indica la variable de salida, es decir, a
dónde irá la salida del programa TKTK.</p>
<p>Una vez construida la espeficicación de la derivación, puede
evaluarla, aunque no es un paso necesario. Se hace con</p>
<pre><code>$ nix eval --file ./example.nix
{ all = [ «repeated» ]; args = [ &quot;-c&quot; &quot;echo Hello &gt; $out&quot; ]; builder = &quot;/bin/sh&quot;; drvAttrs = { args = «repeated»; builder = &quot;/bin/sh&quot;; name = &quot;my-derivation&quot;; system = &quot;x86_64-darwin&quot;; }; drvPath = &quot;/nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv&quot;; name = &quot;my-derivation&quot;; out = «repeated»; outPath = &quot;/nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation&quot;; outputName = &quot;out&quot;; system = &quot;x86_64-darwin&quot;; type = &quot;derivation&quot;; }</code></pre>
<p>Como ve, nos devuelve un conjunto de atributos que especifica una
derivación. En el atributo <code>drvPath</code> muestra el archivo donde
estará la derivación, cuando la creemos. Siempre lo hace bajo
<em>/nix/store</em>. El nombre del archivo de derivación se construye
con un <em>hash</em> que ha calculado con los datos de entrada seguida
de un guión y del nombre que le hemos dado en el parámetro
<code>name</code>.</p>
<p>La razón de ser de ese <em>hash</em> es para que se puedan tener
instancias distintas de un mismo <em>software</em>.</p>
<p>Con el atributo <code>outPath</code> nos muestra la ruta del
ejecutable que se obtendrá al final cuando se construya el ejecutable a
partir de la derivación. También se encontrará ubicado bajo la carpeta
<em>/nix/store</em>.</p>
<p>Para crear realmente la derivación, cosa que llaman
<em>instanciar</em> la derivación, se hace:</p>
<pre><code>$ nix-instantiate ./example.nix
warning: you did not specify &#39;--add-root&#39;; the result might be removed by the garbage collector
/nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv</code></pre>
<p>Se ha hecho de forma correcta, aunque muestre una advertencia
(<em>warning</em>). No se preocupe por esta.</p>
<p>Ahí vuelve a mostrar el mismo archivo de derivación que puso antes.
Puede comprobar que efectivamente ahora existe dicho archivo.</p>
<pre><code>$ ls -lah /nix/store/46wid*
-r--r--r--  1 root  nixbld   286B Jan  1  1970 /nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv</code></pre>
<p>De hecho, en la carpeta <em>/nix/store</em> se tienen también las
derivaciones de todos los paquetes instalados mediante Nix, incluso los
que ha instalado de otros, como puede comprobar con:</p>
<pre><code>$ ls -lah /nix/store/*.drv</code></pre>
<p>Si abre dicho archivo, es decir
<em>/nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv</em>,</p>
<pre><code>Derive([(&quot;out&quot;,&quot;/nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation&quot;,&quot;&quot;,&quot;&quot;)],[],[],&quot;x86_64-darwin&quot;,&quot;/bin/sh&quot;,[&quot;-c&quot;,&quot;echo Hello &gt; $out&quot;],[(&quot;builder&quot;,&quot;/bin/sh&quot;),(&quot;name&quot;,&quot;my-derivation&quot;),(&quot;out&quot;,&quot;/nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation&quot;),(&quot;system&quot;,&quot;x86_64-darwin&quot;)])</code></pre>
<p>advertirá que es básicamente lo mismo que nos mostró con la
evaluación de la espeficicación de la evaluación.</p>
<p>Una vez que se tiene creada la derivación, se debe realizar esta
(<em>to realise it</em>). Se hace del modo siguiente:</p>
<pre><code>$ nix-store --realise /nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv
this derivation will be built:
  /nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv
building &#39;/nix/store/46wid4abl3kj9n991753kh7ndslgkijn-my-derivation.drv&#39;...
warning: you did not specify &#39;--add-root&#39;; the result might be removed by the garbage collector
/nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation</code></pre>
<p>Nos devuelve la misma advertencia de antes. El comando nos devuelve
la ruta del ejecutable construido:
<code>/nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation</code>,
que es la misma que la del parámetro <code>outPath</code> de antes.
Vamos a ejecutarlo para comprobar que se ejecuta correctamente:</p>
<pre><code>$ cat /nix/store/rvs1ggwg147y5r8b2g0845zzlvrv670b-my-derivation
Hello</code></pre>
<p>En cualquier caso, esta forma de construir paquetes tiene muchos
inconvenientes. Me refiero a mediante la función <code>derivation</code>
de <code>builtins</code>. Por ejemplo, en este caso, dependemos de que
se encuentre instalado previamente en el sistema el <em>software</em>
<code>sh</code>, en la ruta que hemos especificado (<em>/bin/sh</em>);
cosa que además debemos conocer. También, que tenemos que TKTK.</p>
<p>Es decir, de este modo, tal y como lo hemos construido
(<em>build</em>) el paquete, tenemos que hacer por nosotros mismos
prácticamente todo.</p>
<p>La forma que tenemos de hacernos la vida más fácil aquí es haciendo
uso de <code>nixpkgs</code>. Vamos a modificarlo para hacerlo más
cómodamente.</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{};</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">builtins</span><span class="op">.</span>derivation <span class="op">{</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-derivation&quot;</span><span class="op">;</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;x86_64-darwin&quot;</span><span class="op">;</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">builder</span> <span class="op">=</span> pkgs<span class="op">.</span>bash<span class="op">;</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">args</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;-c&quot;</span> <span class="st">&quot;echo Hello &gt; $out&quot;</span> <span class="op">];</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>También, en lugar de usar los comandos <code>nix-instantiate</code> y
<code>nix-store --realise</code>, usaremos</p>
<pre><code>$ nix build --file ./example.nix
error: builder for &#39;/nix/store/vkhirw1vzwzxlpa9mrc0qvfmxf8jxrq4-my-derivation.drv&#39; failed with exit code 71;
       last 1 log lines:
       &gt; sandbox-exec: execvp() of &#39;/nix/store/a0a4dznjllw3bicpccvm2nc74zymgyiq-bash-5.2p26&#39; failed: Permission denied
       For full logs, run &#39;nix log /nix/store/vkhirw1vzwzxlpa9mrc0qvfmxf8jxrq4-my-derivation.drv&#39;.</code></pre>
<p>Bueno, esto ha fallado. A él también le falló. Vamos a usar mejor
otras cosas distintas al conjunto de atributos <code>derivation</code>.
Vamos a usar, en su lugar, un <em>helper</em> llamado
<code>runCommand</code> dentro de <code>nixpkgs</code>.</p>
<!--
En el ejemplo donde falla el nix build con pkgs.bash, comentas "A él también
le falló". Sería útil explicar brevemente por qué falla (probablemente por
permisos del sandbox o porque pkgs.bash es una derivación y no una ruta
directa a un ejecutable estático que el builder espera sin más
configuración).
-->
<div class="sourceCode" id="cb117"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{};</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>    pkgs<span class="op">.</span>runCommand <span class="st">&quot;my-derivation&quot;</span> <span class="op">{}</span> <span class="st">&#39;&#39;</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a><span class="st">        echo Hello &gt; $out</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a><span class="st">    &#39;&#39;</span></span></code></pre></div>
<p>Los comentarios multilíena se encierran en Nix entre dos comillas
simples (<code>''</code>).</p>
<p>Ahora, no se queja:</p>
<pre><code>$ nix build --file ./example.nix</code></pre>
<p>A diferencia de antes, ahora no nos ha dado la ruta en la que se
encuentra el paquete instalado. Pero, si consultamos el contenido de la
carpeta desde la que hemos lanzado el comando <code>nix build</code>,
vemos un archivo llamado <em>result</em>, que no estaba antes. Es un
vínculo simbólico a dicho ejecutable.</p>
<pre><code>$ ls -lah
total 16
drwxr-xr-x  5 ctafur  staff   160B Apr 19 13:19 .
drwxr-xr-x  6 ctafur  staff   192B Apr 18 09:45 ..
-rw-r--r--  1 ctafur  staff   114B Apr 19 13:18 example.nix
-rw-r--r--  1 ctafur  staff    48B Apr 18 10:43 other-file.nix
lrwxr-xr-x  1 ctafur  staff    57B Apr 19 13:19 result -&gt; /nix/store/4f1szldkaak4i2zw59wp7mjfjgmj4cqq-my-derivation</code></pre>
<p>No hace falta copiar la ruta. Podemos llamar directamente a
<em>result</em> y se ejecutará el paquete.</p>
<pre><code>$ cat result
Hello</code></pre>
<p>Existen otros <em>wrappers</em> de <code>derivation</code> que se
suelen usar más que <code>runCommand</code>. Por ejemplo,
<code>mkDerivation</code>.</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{};</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>    pkgs<span class="op">.</span>stdenv<span class="op">.</span>mkDerivation <span class="op">{</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-derivation&quot;</span><span class="op">;</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">builder</span> <span class="op">=</span> <span class="st">&quot;/bin/sh&quot;</span><span class="op">;</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">args</span> <span class="op">=</span> <span class="op">[</span> <span class="st">&quot;-c&quot;</span> <span class="st">&quot;echo Hello &gt; $out&quot;</span> <span class="op">];</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">src</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>El parámetro <code>src</code> es obligatorio en esta función. Es
importante no olvidar que una derivación requiere de una fuente
(<em>source</em>). En este caso, le hemos dado la carpeta actual.</p>
<p>Se instalaría del mismo modo que antes:</p>
<pre><code>$ nix build --file ./example.nix
$ cat result
Hello</code></pre>
<p>La función <code>mkDerivation</code> hace más cosas que
<code>runCommand</code>. Por ejemplo, permite crear fases
(<em>phases</em>) en la construcción del paquete, que sería parecido a
las capas en la construcción de una imagen de contenedores OCI.</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{};</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    pkgs<span class="op">.</span>stdenv<span class="op">.</span>mkDerivation <span class="op">{</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-derivation&quot;</span><span class="op">;</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">src</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">installPhase</span> <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a><span class="st">            echo Hello &gt; $out</span></span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a><span class="st">        &#39;&#39;</span><span class="op">;</span></span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Se construye como antes:</p>
<pre><code>$ nix build --file ./example.nix
$ cat result
Hello</code></pre>
<p>La diferencia entre <code>mkDerivation</code> y
<code>runCommand</code> está en que este último está más pensado para
introducir <em>scripts</em> de <em>shell</em>, mientras que el primero
es para hacer derivaciones realmente. Siempre se pueden hacer con
<code>derivation</code>, pero es mucho más trabajoso y hay que tener en
cuenta muchas más cosas. Sin embargo, con estos dos <em>helpers</em> o
<em>wrappers</em> es mucho más cómodo.</p>
</section>
<section id="el-sistema-module" class="level2">
<h2>El sistema <em>module</em></h2>
<p>Es una forma genérica de proporcionar configuración.</p>
<p>Vamos a probar con estos en el REPL.</p>
<p>Lo primero que vamos a hacer es cargar <code>nixpkgs</code>:</p>
<pre><code>nix-repl&gt; :l &lt;nixpkgs&gt;</code></pre>
<p>Ahora,</p>
<pre><code>nix-repl&gt; modulea = { options.a.enable = lib.mkEnable.Options; }</code></pre>
<!-- MINUTO 55. Lo cierto es que esta parte es bastante caótica. No sé qué
es lo que quería hacer ahí. -->
<p>Es decir,</p>
<pre><code>nix-repl&gt; :l &lt;nixpkgs&gt;
nix-repl&gt; modulea = { options.a.enable = lib.mkEnable.Options; }
nix-repl&gt; result = lib.evalModules { modules = [ modulea ]; }
nix-repl&gt; result
{ _module = { ... }; _type = &quot;configuration&quot;; class = null; config = { ... }; extendModules = «lambda @ /nix/store/kldyrambq3k5kgg61x2qrcwnyljmfwqq-nixpkgs/nixpkgs/lib/modules.nix:303:23»; options = { ... }; type = { ... }; }
nix-repl&gt; result.options
{ _module = { ... }; a = { ... }; }
nix-repl&gt; result.options.a
{ enable = { ... }; }
nix-repl&gt; result.options.a.enable
{ __toString = «lambda @ /nix/store/kldyrambq3k5kgg61x2qrcwnyljmfwqq-nixpkgs/nixpkgs/lib/modules.nix:816:22»; _type = &quot;option&quot;; declarationPositions = [ ... ]; declarations = [ ... ]; default = false; definitions = [ ... ]; definitionsWithLocations = [ ... ]; description = &quot;Whether to enable A.&quot;; example = true; files = [ ... ]; highestPrio = 1500; isDefined = true; loc = [ ... ]; options = [ ... ]; type = { ... }; value = false; }
nix-repl&gt;
nix-repl&gt;
nix-repl&gt; moduleb = { options.b.enable = lib.mkEnableOption &quot;B&quot;; } 
nix-repl&gt; result = lib.evalModules { modules = [ moduleb ]; }      
nix-repl&gt; result.options
{ _module = { ... }; b = { ... }; }
nix-repl&gt;
nix-repl&gt; result.options.b.enable
{ __toString = «lambda @ /nix/store/kldyrambq3k5kgg61x2qrcwnyljmfwqq-nixpkgs/nixpkgs/lib/modules.nix:816:22»; _type = &quot;option&quot;; declarationPositions = [ ... ]; declarations = [ ... ]; default = false; definitions = [ ... ]; definitionsWithLocations = [ ... ]; description = &quot;Whether to enable B.&quot;; example = true; files = [ ... ]; highestPrio = 1500; isDefined = true; loc = [ ... ]; options = [ ... ]; type = { ... }; value = false; }</code></pre>
<p>Como puede ver, ambos han sido combinados. Es decir, todos los
módulos colapsan (<em>collapse</em>).</p>
<p>Todos los módulos toman 3 cosas: <code>options</code>,
<code>config</code> y <code>imports</code>. El último ya lo hemos visto.
<code>options</code> es lo que hemos visto ahora mismo. Donde las cosas
sí son algo diferentes es con <code>config</code>.</p>
<pre><code>nix-repl&gt; moduleb = { config = { a.enable = true; }; }
nix-repl&gt; result = lib.evalModules { modules = [ modulea moduleb ]; }
nix-repl&gt; result.config.a.enable
true</code></pre>
<p>Sin embargo,</p>
<pre><code>nix-repl&gt; result = lib.evalModules { modules = [ moduleb ]; }
nix-repl&gt; result.config.a.enable
error: The option `a&#39; does not exist. Definition values:
       - In `&lt;unknown-file&gt;&#39;:
           {
             enable = true;
           }

       It seems as if you&#39;re trying to declare an option by placing it into `config&#39; rather than `options&#39;!</code></pre>
<p>Esto sería como un error de tipos en el sistema de módulos.</p>
<p>Ahora, vamos a crear una opción de un tipo customizado.</p>
<pre><code>nix-repl&gt; modulec = { options.output = lib.mkOption { type = lib.types.str; }; }
nix-repl&gt; result = lib.evalModules { modules = [ modulea moduleb modulec ]; }
nix-repl&gt; moduleb = { config, ... }: { config = { output = &quot;something&quot;; }; }
nix-repl&gt; result = lib.evalModules { modules = [ modulea moduleb modulec ]; }
nix-repl&gt; result.config
{ a = { ... }; output = &quot;something&quot;; }</code></pre>
<p>Ahora, deseamos que la configuración de <code>moduleb</code> solo se
habilite cuando se <q>encienda</q> <code>A</code>.</p>
<pre><code>nix-repl&gt; moduleb = { config, ... }: { config = lib.mkIf config.a.enable { output = &quot;something&quot;; }; }
nix-repl&gt; result = lib.evalModules { modules = [ modulea moduleb modulec ]; }
nix-repl&gt; result.config
{ a = { ... }; output = «error: error: The option `output&#39; is used but not defined.»; }</code></pre>
</section>
</section>
<section id="paquetes-instalados" class="level1">
<h1>Paquetes instalados</h1>
<pre><code>age
bash
starship
gnugrep
gh
tree-sitter
ffmpeg-full
noto-fonts-cjk-sans
noto-fonts-lgc-plus
xz
zstd
neovim
typst
typst-lsp
typstfmt
atuin
stylua
sqls
restic
ripgrep
go
zsh-autocomplete
zsh-completions
gopls
yaml-language-server
nix-zsh-completions
darwin.cctools
gnupg
gnumake
wget
macfuse-stubs
gawk
p7zip
ccls
texlive-combined-full-2023-final
texlab
tree-sitter-rst-grammar
tree
bash-completion
nix-bash-completions
open-pdf-sign
go-task
mpv
jetbrains-mono</code></pre>
<p>Otros que quizás me interesaría instalar:</p>
<pre><code>sqlite
lua
# luajit -- Conflicto con lua
font-jetbrains-mono-nerd-font
python3
python3-yt-dlp
pandoc
onlyoffice-bin -- quizás</code></pre>
<p>Quizás, la de las fuentes es mejor quitarla de Homebrew y usar
simplemente la de Nix.</p>
<p>Para entornos de C:</p>
<pre><code>gdb
valgrind</code></pre>
</section>
<!--</main>-->
</body>
</html>
