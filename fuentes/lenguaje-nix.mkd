


## Lenguaje Nix

El uso de Nix como gestor de paquetes no ha sido nunca el propósito
principal de sus creadores. Para sacar el máximo provecho de Nix debe
aprender a crear y gestionar entornos con este. Para esto, debe aprender lo
básico del lenguaje Nix.

Los dos videotutoriales que he seguido aquí son [el de
Vimjoyer][vimjoyer-nix-lang] y el [Nix From Nothing #1][].

[vimjoyer-nix-lang]: https://www.youtube.com/watch?v=UgrwoAGSPOQ
[Nix From Nothing #1]: https://www.youtube.com/watch?v=t8ydCYe9Y3M

Más riguroso es [el tutorial][nix-docs-lang-tuto] sobre el lenguaje Nix en
la documentación oficial de Nix. También, [el tutorial de
Nix.dev][nix-dev-tuto-nix-lang]. Además, se tiene como referencia [lo que
explican][nix-lang-ref] en el manual oficial, que le dará un conocimiento
más completo.

[nix-docs-lang-tuto]: https://nixos.org/guides/nix-pills/04-basics-of-language.html
[nix-dev-tuto-nix-lang]: https://nix.dev/tutorials/nix-language
[nix-lang-ref]: https://nixos.org/manual/nix/stable/language/

El lenguaje Nix, tal y como ya se ha dicho, se adhiere mucho al paradigma
funcional puro. Es bastante parecido a Haskell, por lo que si ha programado
en este tiene gran parte del "recorrido" hecho.





### El intérprete

Podríamos entrar al intérprete (también llamados REPL) de Nix con el comando
`nix repl`:

```
$ nix repl
Nix 2.28.3
Type :? for help.
nix-repl>
```

Podríamos introducir expresiones como la siguiente y nos devuelve la
evaluación de la misma:

```
nix-repl> 9 + 9
18
```

También podemos evaluar las expresiones almacenadas en un archivo. Por
ejemplo, si desde nuestro _shell_ (salga del REPL) creamos un archivo
_expresion.nix_ que contenga la expresión

```nix
9 + 9
```

podemos evaluarla con el comando siguiente de su _shell_:

```
$ nix-instantiate --eval expresion.nix
18
```




### Tipos de datos

En cuanto a las características del tipado en Nix, hay que decir que se
trata de tipado fuerte (_strongly typed_), pero aun así no cuenta con tipado
estático sino dinámico (_dynamic typed_).




#### Tipos simples

Cuenta con varios tipos de datos predefinidos (_built-in_, también llamados
_primitivos_). Los tipos de datos simples (también llamados _atómicos_) son:
entero (_integer_),

```
nix-repl> 7
7
```

coma (o punto) flotante (_floating point_),

```
nix-repl> 7.1
7.1
```

cadena (_string_),

```
nix-repl> "cadena"
"cadena"

nix-repl> ''cadena''
"cadena"
```

ruta (_path_),

```
nix-repl> ./.
/Users/usuario
```

buleano (_Boolean_),

```
nix-repl> true
true
```

nulo (_null_),

```
nix-repl> null
null
```

Quizás le llame la atención el tipo de datos ruta. Tiene sentido debido al
uso de Nix. TKTK.

También es predefinido el tipo de datos lista (_list_), aunque este no es
simple. Un ejemplo de lista sería el siguiente:

```nix
[ "uno" "dos" "tres" ]
```

Veámosla en el REPL:

```
nix-repl> [ "uno" "dos" "tres" ]
[
  "uno"
  "dos"
  "tres"
]
```




#### Conjuntos de atributos

El tipo de datos predefinido más interesante en Nix es el **conjunto de
atributos** (_attribute set_). Se trata de algo parecido a los diccionarios
de Python o los mapas de _hash_ en otros lenguajes. Evidentemente, también
se trata de un tipo de datos no simple. Un ejemplo sería el siguiente:

```nix
{
    one = "hello";
    two = "world";
    three = "something";
}
```

Veámoslo en el REPL:

```
nix-repl> { one = "hello"; two = "world"; three = "something"; }
{
  one = "hello";
  three = "something";
  two = "world";
}
```

A veces lo llaman _conjunto_ (_set_) a secas. Advierta el punto y coma al
final de cada entrada; este es obligatorio siempre. A cada entrada del
"conjunto" (separadas por `;`) se la conoce como **atributo** (_attribute_).
(Lo pongo entrecomillado porque realmente no existe en Nix el tipo
conjunto.)

Haciendo una analogía con los diccionarios de Python, cada atributo consta
de una clave (_key_), cosa que en Nix llaman _nombre de atributo_
(_attribute name_), y un _valor_ (_value_).

Advierta que los conjuntos de atributos pueden ser heterogéneos:

```
nix-repl> { one = "hello"; two = "world"; three = 3; }
{
  one = "hello";
  three = 3;
  two = "world";
}
```

También se permite el anidamiento (_nesting_) de conjuntos de atributos,

```
nix-repl> { one = "hello"; two = "world"; three = "something"; x = { a = 1; b = true; }; }
{
  one = "hello";
  three = "something";
  two = "world";
  x = { ... };
}
```

Alternativamente, la anidación de conjuntos de atributos se puede
especificar mediante la notación con punto, como en el ejemplo siguiente:

```
nix-repl> { one = "hello"; two = "world"; three = "something"; x.a = 1; x = { b = true; }; }
{
  one = "hello";
  three = "something";
  two = "world";
  x = { ... };
}
```

Ambos evaluarían al mismo conjunto de atributos.

Para tomar un valor de un conjunto de atributos, podemos usar también la
notación con punto:

```
nix-repl> { one = "hello"; two = "world"; }.one
"hello"
```

Tras el punto, se indica el nombre del atributo del que queremos obtener el
valor.

Si se fija, hasta ahora únicamente hemos hecho uso de literales
(_literals_). Podemos también hacer uso de variables:

```
nix-repl> myvar = { one = "hello"; two = "world"; }

nix-repl> myvar.one
"hello"
```

Advierta que no hemos tenido que especificar el tipo de la variable.

En cada archivo Nix se tiene una única expresión, por lo que lo anterior no
es algo que pueda encontrarse en su uso de Nix. Es así por tratarse de un
lenguaje funcional puro.

Si deseamos hacer uso de variables en un archivo Nix, tenemos las
**expresiones _let_** (_let expressions_). Por ejemplo,

```
nix-repl> let
              my-var = {
                  one = "hello";
                  two = "world";
              };
          in
"hello"
```

Esto mismo, en un archivo Nix seria

```nix
let
    my-var = {
        one = "hello";
        two = "world";
    };
in
    my-var.one
```

que evaluaría a `"hello"`.

En la parte _let_ se declaran las variables y, en la _in_, se hace uso de
estas. Por cierto, Nix tiene la propiedad de evaluación perezosa (_lazy
evaluation_).

También podemos hacer que una expresión _let_ sea un valor en un atributo
(dentro de un conjunto de atributos):

```nix
{
    x =
        let
            a = 5;
            b = 4;
        in a + b;
    y = 10;
}.x
```

que evaluaría a `9`.

Opcionalmente, se podría añadir paréntesis (`( )`) alrededor de la expresión
_let_. Aunque no afecta al resultado, se usa con el único propósito de hacer
más legible el código.

```nix
{
    (x =
        let
            a = 5;
            b = 4;
        in a + b);
    y = 10;
}.x
```

Las expresiones _let_ y las _in_ son parseadas recursivamente hasta que sean
evaluadas todas las variables, lo cual significa que incluso podemos usar
variables en las expresiones de otras variables.

```nix
{
    (x =
        let
            a = 5;
            b = a + 4;
        in a + b);
    y = 10;
}.x
```

<!-- Por el minuto 4 hay cosas que no he copiado -->

Advierta que se puede hacer uso de la interpolación de cadena (_string
interpolation_, también llamadas _string templates_) en las expresiones
_let-in_. Se marca con `${}`.

```
nix-repl> let nombre = "Carlos"; in "hola, ${nombre}"
"hola, Carlos"
```

En los conjuntos de atributos desearíamos poder hacer uso de la recursión
para referenciar variables entre ellas. Para hacer esto, se debe hacer uso
de la palabra clave `rec`, como en el ejemplo siguiente:

```
nix-repl> { a = 5; b = a + 5; }
error: undefined variable 'a'
       at «string»:1:14:
            1| { a = 5; b = a + 5; }
             |              ^

nix-repl> rec { a = 5; b = a + 5; }
{
  a = 5;
  b = 10;
}
```




#### Listas

Volvamos a las listas. Tal y como dijimos, también pueden ser heterogéneas:

```nix
[ "hello" 4 true ]
```

La separación de los elementos en la lista se marca con espacios. Pueden ser
uno o más. Los espacios entre los corchetes (que indican que se trata de una
lista) y los elementos de la lista no tiene por qué hacerse con espacios
entre ambos, pero se suele seguir la regla de estilo de poner ahí un
espacio.

Algo que se puede usar también en las listas es la palabra clave `with`.
Gracias a esta, tenemos una forma alternativa de expresar una expresión
_let-in_. Por ejemplo,

```
nix-repl> with { a = 5; b = 6; c = 7; }; [ "hello" 4 a b ]
[
  "hello"
  4
  5
  6
]
```

que sería lo mismo que lo siguiente:

```
nix-repl> let a = 5; b = 6; c = 7; in [ "hello" 4 a b ]
[
  "hello"
  4
  5
  6
]
```

La palabra clave `with` puede usarse en otras estructuras distintas a las
listas; por ejemplo, en conjuntos de atributos:

```
nix-repl> with { a = 5; b = 6; c = 7; }; { five = a; six = b; }
{
  five = 5;
  six = 6;
}
```




#### Funciones

Ahora, pasemos a las funciones, ya que Nix es un lenguaje funcional puro.
Veamos primero una función muy sencilla:

```
nix-repl> my-func = a: a + 1

nix-repl> my-func 3
4
```

Lo primero es la definición (_definition_) y después ponemos la llamada
(_call_) o invocación de la misma.

Nix tiene funciones anónimas (_anonymous functions_, también llamada
_funciones lambda_, _lambda functions_). Un ejemplo sería la anterior:

```
a: a + 1
```

La sintaxis es muy sencilla. Se pone el argumento seguido del signo de dos
puntos, `:`, y a la derecha se pone el cuerpo (_body_) de la misma.

Estas pueden usarse como valores que se pueden asignar a variables, como se
hace en

```
my-func = a: a + 1
```

Esta funcionalidad suele recibir el nombre de _funciones de primera clase_
(_first-class functions_).

Para tener lo anterior como una sola expresión (y poder usarla como archivo
Nix), la incluiríamos en una expresión _let-in_:

```
nix-repl> let my-func = a: a + 1; in my-func 3
4
```

Al respecto de los argumentos de las funciones, en Nix existe la restricción
de que este solo puede ser uno. Esto no es un problema ya que puede hacer lo
que en programación funcional llaman _currying_, que consiste en especificar
las funciones anidándolas unas dentro de otras. Por ejemplo,

```
nix-repl> let my-func = a: b: (a + 1) * b; in my-func 3 7
28
```

Como estamos haciendo anidación, si pasamos un solo argumento a esa función
tendremos que la salida será una función solo que con un argumento menos,
que será sustituido por un valor en concreto. Por ejemplo,

```nix
let
    my-func = a: b: (a + 1) * b;
    my-func-unwrapped = my-func 3;
in
    my-func-unwrapped 7
```

que evalúa a `28`. Si se fija, aquí la función `my-func-unwrapped` tiene
como valor a la función

```
b: (3 + 1) * b
```

Metafóricamente, sería como pelar una cebolla. Como ve, aunque sirve para
tener varios argumentos, no llega a ser lo mismo exactamente.
Alternativamente, existe otra forma de especificar varios argumentos, que se
comporta de un modo más parecido a lo que deseamos. Simplemente consiste en
usar como parámetro o argumento un conjunto de atributos.

```nix
let
    my-func = { a, b, }: a + b;
in
    my-func { a = 9; b = 15; }
```

que evalúa a `24`. Advierta que se tiene que poner una coma después del
último parámetro.

<!-- Inherit -->

Las funciones en Nix cuentan también con valores predefinidos para los
argumentos. Para esto, se usa el signo de cierre de interrogación, `?`.

```nix
let
    my-func = { a ? 100, b, }: a + b;
in
    my-func { b = 15; }
```

que evalúa a `115`.

Como sucede en otros lenguajes, se usa el valor predefinido únicamente si no
se pasa un valor de forma explícita al parámetro.

Si añadimos como argumento un signo de tres puntos (como los puntos
suspensivos, _elipsis_), `...`, cualquier atributo adicional, a partir del
segundo, será ignorado. Pero si también añadimos a la derecha de ese
argumento (el conjunto de atributos) el símbolo arroba, `@`, seguido de
algún nombre, TKTK.

<!-- Volver a esto. Minuto 7:30 -->

```nix
let
    my-func = { a ? 100, b, ... }@args:
    if args.c then a else b;
in
    my-func { b = 15; c = true; }
```

que evalúa a `100`.










### Tipos de datos

La estructura de datos principal de Nix es la que se conoce como _conjunto
de atributos_ (_attributes set_), que sería en cierto modo parecido a los
diccionarios de Python (tiene muchos nombres; además de estos, tabla _hash_,
arreglo asociativo, mapas, etc.). Tiene una sintaxis muy parecida a la del
formato JSON.

También, hay que tener en cuenta que, ya que se adhiere bastante al
paradigma funcional, en Nix lo que se maneja son expresiones
(_expressions_); no afirmaciones (_statements_). Esto permite al lenguaje
prescindir del signo de punto y coma (`;`, _semicolon_) al final. En
cualquier caso, por razones de expresividad, se ha dado otro uso a dicho
símbolo; concretamente, se usa para separar los distintos elementos dentro
de un conjunto de atributos.

Lo siguiente sería un literal de un conjunto de atributos. Por ejemplo,

```nix
{
    name1 = "value1";
    name2 = "value2";
}
```

Tal y como hemos dicho, sería equivalente a un diccionario.

Si en su instalación de Nix tiene activado _flakes_, si introduce lo
anterior en un archivo como, por ejemplo, _example.nix_, podemos evaluar ese
conjunto de atributos con el comando siguiente:

```
$ nix eval --file example.nix
{ name1 = "value1"; name2 = "value2"; }
```

El uso del punto y coma en los elementos de un conjunto de atributos es
obligatorio, incluso en el último de estos (de los elementos).

Otro tipo de dato estructurado que se tiene son las listas (_lists_). Serían
lo mismo que las listas en Python (mutabilidad? mejor, las tuplas?). TKTK.
Un literal de lista sería, por ejemplo,

```nix
[
    1
    2
    3
]
```

El espacio o nuevo renglón es el que sirve para delimitar los elementos en
la lista. La anterior sería igual a la siguiente:

```nix
[ 1 2 3 ]
```

Aunque se suele usar como regla de estilo dejar un espacio entre los
delimitadores y los elementos en su interior, este lo podríamos eliminar si
lo deseáramos:

```nix
[1 2 3]
```



### `let` _bindings_

Aunque se tenga una expresión declarativa, se pueden especificar valores de
variables en esta, tal y como se hace, por ejemplo, en las _list
comprehensions_ de Python. En Nix sucede algo similar. Para esto se usan los
`let` _bindings_. Por ejemplo,

```nix
let
    myNumber = 42;
in
    myNumber + 1
```

Ojo con el punto y coma antes del `in`. Al ser un conjunto de atributos lo
que introducimos dentro de `let`, debrá tener punto y coma cada uno de los
elementos ahí. Lo que hay tras `in` es una expresión que hace uso de ese
conjunto de atributos.

```
$ nix eval --file 01.nix
43
```

Como ve, sigue siendo una expresión pero esta vez esta tiene en cuenta el
valor de la variable `myNumber`.

Lo considero en realidad una expresión porque lo importante es lo que va
tras la palabra clave `in`. Lo que va entre `let` e `in` es simplemente para
hacer a la expresión consciente de los valores de ciertas variables. En
cualquier caso, ya no estamos en un paradigma funcional puro; bueno, eso
depende de cómo se considere TKTK.

En cualquier caso, esas variables están confinadas a esa expresión, es
decir, no tenemos variables globales y, por tanto, no se puede afirmar que
el programa ejecutándose pase por estados diversos.





### Funciones

Nix cuenta también, evidentemente, con funciones. Por ejemplo, así se
definiría y se invocaría una función que decidimos llamar `greet()`.

```nix
let
    greet = name: "Hello, ${name}!";
in
    greet "Carlos"
```

Como ve, la función se define asignando una definición de función anónima
(_anonymous function_; a estas también las suelen llamar _funciones lambda_,
_lambda functions_) a una variable (en este caso, `greet`), y esto se hace
dentro de la parte `let` de un `let` _binding_.

En la definición de la función, lo primero que se pone son los parámetros (o
parámetros formales). A la derecha de estos, un signo de dos puntos (`:`,
_colon_), y a su derecha, la propia definición de la función; o su firma
(_signature_), se podría decir también.

En la parte `in`, se puede invocar la función, con los argumentos (o
parámetros reales) que deseemos. En este caso, el argumento es el literal de
cadena `Carlos`. Las comillas sirven para delimitar al literal de cadena y,
en este caso, no forman parte del mismo; al igual que suele suceder con la
mayoría de lenguajes de programación.

La sintaxis suele evitar el uso de signos de llaves (`{ }`) y paréntesis
(`()`). También, como ve, se hace interpolación de cadena (_string
interpolation_, o plantilla de cadena, _template string_) en los literales
de cadena, al igual que en tantos otros lenguajes. En este caso, tiene la
forma `${<var>}` donde `<var>` será la variable de la que se tomará el valor
para insertar en esa parte de la cadena.

Al evaluar la expresión `let-in` anterior, dará como resultado

```
$ Hello, Carlos!
```

como es evidente.

Si deseamos una función que tenga más de un parámetro de entrada, se puede
usa lo que en programación funcional llaman el _currying_, es decir, hacer
uso de una función dentro de otra.

```nix
let
    greet = greeting: name: "${greeting}, ${name}!";
in
    greet "Howdy" "Carlos"
```

que devolverá

```
$ Howdy, Carlos!
```

Como ve, cuando se dan varios argumentos a una llamada de una función, estos
se separan mediante espacio.

Ahora, vamos a mezclar las funciones con conjuntos de atributos.

```nix
let
    makeSecret = secret: {
        mySuperSecretValue = secret;
    };
in
    makeSecret "abcd"
```

que daría

```
$ nix eval --file example.nix
{ mySuperSecretValue = "abcd"; }
```

En este caso, la definición de la función es básicamente un conjunto de
atributos, como puede ver. Por tanto, lo que devuelve la función será eso
mismo.

Por cierto, de momento, como verá, estamos haciendo uso de argumentos
posicionales en las funciones. Ahora, vamos a ver cómo se haría uso de
argumentos nombrados.

También, se le podría pasar un conjunto de atributos como argumento a la
función.

```nix
let
    makeSecret = secret: {
        mySuperSecretValue = secret;
    };
in
    makeSecret { key = "my_secret"; value = "super-secret"; }
```

que daría

```
$ nix eval --file example.nix
{ mySuperSecretValue = { key = "my_secret"; value = "super-secret"; }; }
```

Ojo con el punto y coma tras `"super-secret"`. En realidad, aquí no hemos
hecho nada, es decir, este ejemplo no tiene ningún sentido.

Pero quizás no era eso lo que deseábamos hacer, sino lo siguiente:

```nix
let
    makeSecret = { key, value }: {
        mySuperSecretValue = value;
    };
in
    makeSecret { key = "my_secret"; value = "super-secret"; }
```

que da

```
$ nix eval --file example.nix
{ mySuperSecretValue = "super-secret"; }
```

Como ve, solo muestra el atributo al que se le da hado un valor. El otro, al
no haber recibido ningún valor, no lo muestra, pues, en la definición de la
función, no se da ningún uso al parámetro `key`.

¿Pero cómo podríamos modificar esta función para que sí que haga uso del
parámetro `key` en la clave del conjunto de atributos? Es muy sencillo; no
hay más que usar la interpolación de cadena:

```nix
let
    makeSecret = { key, value }: {
        "${key}" = value;
    };
in
    makeSecret { key = "my_secret"; value = "super-secret"; }
```

que da

```
$ nix eval --file example.nix
{ my_secret = "super-secret"; }
```

Podríamos haber puesto la clave sin comillas y también sería válido.

```nix
let
    makeSecret = { key, value }: {
        ${key} = value;
    };
in
    makeSecret { key = "my_secret"; value = "super-secret"; }
```

que da

```
$ nix eval --file example.nix
{ my_secret = "super-secret"; }
```

Si en la definición de la función solo se hubiera especificado el parámetro
`value` y, luego, en la llamada, se ponen ambos, nos dará un error.

```nix
let
    makeSecret = { value }: {
        mySuperSecretValue = value;
    };
in
    makeSecret { key = "my_secret"; value = "super-secret"; }
```

que daría

```
❯ nix eval --file example.nix
error: 'makeSecret' at /Users/ctafur/temp/nix/nix-from-nothing-tuto/dos/example.nix:2:18 called with unexpected argument 'key'

       at /Users/ctafur/temp/nix/nix-from-nothing-tuto/dos/example.nix:6:5:

            5| in
            6|     makeSecret { key = "my_secret"; value = "super-secret"; }
             |     ^
            7|
(use '--show-trace' to show detailed location information)
```

Si deseamos dejar abierta la posibilidad de que se pueda llamar a otros
argumentos no especificados en la definición de una función, se puede usar
la notación de elipsis (_ellipsis_): `...`, para indicarlo.

```nix
let
    makeSecret = { value, ... }: {
        mySuperSecretValue = value;
    };
in
    makeSecret { key = "my_secret"; value = "super-secret"; }
```

que da

```
$ nix eval --file example.nix
{ mySuperSecretValue = "super-secret"; }
```

Es decir, tampoco hace uso del parámetro `key`, pero esta vez no da error.

Advierta que, en el literal de conjunto de atributos que se usa en la
definición de la función, las variables en las claves, para ser sustituidas
por su valor, deben usar la notación de interpolación de cadena, mientras
que con los valores no sucede esto. Es decir, lo siguiente

```nix
let
    makeSecret = { key, value }: {
        key = value;
    };
in
    makeSecret { key = "my_secret"; value = "super-secret"; }
```

daría

```
$ nix eval --file example.nix
{ key = "super-secret"; }
```

que no es lo que deseábamos en este caso.

También, se podría hacer más dinámico:

```nix
let
    makeSecret = { key, value }: {
        "user-key:${key}" = value;
    };
in
    makeSecret { key = "my_secret"; value = "super-secret"; }
```

que da

```
$ nix eval --file example.nix
{ "user-key:my_secret" = "super-secret"; }
```

Si queremos hacer lo siguiente:

```nix
let
    makeSecret = { key, value }: {
        value = value;
    };
in
    makeSecret { key = "my_secret"; value = "super-secret"; }
```

se puede hacer de forma abreviada usando el enunciado `inherit`:

```nix
let
    makeSecret = { key, value }: {
        inherit value;
    };
in
    makeSecret { key = "my_secret"; value = "super-secret"; }
```

En ambos casos, se tendría como resultado

```
$ nix eval --file example.nix
{ value = "super-secret"; }
```

Imagino que el uso que se da a `inherit` será para hacer pruebas sobre los
estados de las variables, al igual que en Python se hace con `f"variable="`.

También, se puede tener una función dentro de un conjunto de atributos. La
forma de acceder a este es mediante la notación punto.

```nix
let
    conj_atrib = {
        greet = greeting: name: "${greeting}, ${name}!";
    };
in
    conj_atrib.greet "Howdy" "Carlos"
```

TKTK.

También, debe saber que los comentarios son el símbolo `#` para comentar
hasta final de línea, y, `/*` y `*/`, para abrir y cerrar, respectivamente,
un comentario multilínea.





<!-- --------------------------------------------------------------- -->

Llegados a este punto, básicamente hemos visto lo básico del lenguaje Nix.
Lo natural sería que el paso siguiente consistiera en integrar este
conocimiento con Nixpkgs, que son los paquetes junto con una serie de
fuciones. TKTK. Entre las cosas que haremos con Nixpkgs se encuentran crear
_helper functions_ para mapas (_maps_), para filtros (_filters_), etc.

Vamos a ver primero cómo se importan otros archivos de Nix.

Creamos el archivo _other-file.nix_ con el contenido siguiente:

```nix
{
    greet = name: "Hello, ${name}!";
}
```

Como ve, lo único que contiene es un conjunto de atributos cuyo único
elemento tiene por clave la cadena `"greet"` y, por valor, una función
anónima.

Ahora, vamos a crear otro archivo Nix, que llamaremos _example.nix_, desde
el que cargaremos el anterior archivo Nix, _other-file.nix_. En
_example.nix_, incluiremos lo siguiente:

```nix
let
    myLibrary = import ./other-file.nix;
in
    myLibrary
```

que da

```
$ nix eval --file example.nix
{ greet = <LAMBDA>; }
```

En _example.nix_ se la incluido, dentro de un `let` _binding_, una
importación del contenido de otro archivo Nix; concretamente, de
_other-file.nix_. El resultado de evaluar _example.nix_ es el esperado. En
la información que nos da la evaluación, la parte `<LAMBDA>` indica una
función anónima, pero sin especificar el contenido de esta. En cualquier
caso, la forma de invocarla es usar la clave asociada a la misma en la
tabla, es decir, `greet`. Pero ese atributo está dentro del conjunto de
atributos `myLibrary`, por lo que deberá llamar al `greet` de `myLibrary`,
cosa que puede hacer usando el operador punto, tal y como se explicó antes.

```nix
let
    myLibrary = import ./other-file.nix;
in
    myLibrary.greet "Carlos"
```

que da

```
$ nix eval --file example.nix
"Hello, Carlos!"
```

Esto mismo se puede hacer con los paquetes Nix.

```nix
let
    pkgs = import <nixpkgs>;
in
    pkgs
```

que da

```
$ nix eval --file example.nix
<LAMBDA>
```

Como es una función (ya que pone `<LAMBDA>`, se debería especificar algún
parámetro, o varios de estos en un conjunto de atributos. En realidad,
`<nixpkgs>` es una función que a su vez contiene muchas cosas a distintos
niveles de anidamiento: funciones y conjuntos de atributos, principalmente.

```nix
let
    pkgs = import <nixpkgs> {};
in
    pkgs.lib
```

Esto nos mostrará todo lo que hay en el atributo `lib` dentro de la lista de
paquetes (`nixpkgs`). La salida es bastante grande. Tenga cuidado de no
intentar llamar a `pkgs`, que llamaría a todos los paquetes. Lo hice, al
seguir este tutorial, y tuve que terminar reiniciando el computador, ya que
son muchos los paquetes incluidos actualmente.

Con `<nixpkgs>`, lo que hemos hecho es usar esa biblioteca tomada de nuestro
entorno, es decir, de la de nuestra instalación de Nix. Se podría haber
optado, alternativamente, a tomarla de su repositorio en GitHub, por
ejemplo, o de algún otro sitio, especificando la URL que correspondiera.

Con el comando siguiente, se puede consultar de dónde lo toma su instalación
local:

```
$ nix-channel --list
nixpkgs https://nixos.org/channels/nixpkgs-unstable
```






### REPL

Una forma bastante cómoda de hacer pruebas con la biblioteca `nixpkgs` es
desde el REPL de Nix. Si tiene activado _flakes_, se entra con

```
$ nix repl
nix-repl>
```

Una diferencia con el lenguaje en los archivos es que en el REPL no tiene
que terminar con punto y coma. También, se pueden asignar valores a
variables sin usar `let`-`in`.

Tiene autocompletado, por lo que puede ir viendo los elementos de las
distintas bibliotecas.

```
nix-repl> pkgs = import <nixpkgs> {}
nix-repl> pkgs.lib.
```

Si ahí, sin pulsar [Intro]{.kbd}, pulsa [Tab]{.kbd} para hacer
_tab-completion_, se mostrará todo lo que hay bajo el conjunto de atributos
`lib` de `nixpkgs`.

Además de los distintos elementos de `nixpkgs`, nuestra instalación trae
siempre ciertos elementos de serie. A esto los llaman _builtins_. Puede
consultarlos también:

```
nix-repl> builtins.
```

y pulse [Tab]{.kbd}. Por ejemplo, tenemos la función `derivation` dentro de
`builtins`, a la que podemo hacer alusión con `builtins.derivation`.

```
nix-repl> builtins.derivation
«lambda @ /builtin/derivation.nix:5:1»
```

Como vemos, es una función, ya que pone `lambda`. Esta función tiene varios
argumentos obligatorios. Si tratamos de invocarla sin esos argumentos,

```nix
builtins.derivation {}
```

nos dará un error.

```
$ nix eval --file example.nix
error:
       … while evaluating the attribute 'outPath'

         at /builtin/derivation.nix:19:9: (source not available)

       … while calling the 'getAttr' builtin

         at /builtin/derivation.nix:19:19: (source not available)

       (stack trace truncated; use '--show-trace' to show the full trace)

       error: attribute 'name' missing
```

Vamos a ver los argumentos:

```nix
builtins.derivation {
    name = "my-derivation";
}
```













