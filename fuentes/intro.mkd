



## Introducción

Nix es una tecnología que ha comenzado a alcanzar popularidad en los últimos
años debido a que soluciona algunos de los problemas que se tenían en el
despliegue (_deployment_) de _software_ y que tecnologías modernas como los
contenedores OCI (por ejemplo, los de Docker), no llegaban a solucionar.

El gran problema con el despliegue se suele resumir en la frase "En mi
máquina funciona.". Es decir, un desarrollador trabaja en un entorno
(_environment_) ---su sistema--- distinto al sistema en el que terminará
ejecutándose ese _software_. Esto produce muchos problemas, y, de hecho,
tradicionalmente se reservaba una franja de tiempo del proyecto para la
adaptación del _software_ al entorno nuevo.

La llegada de los contenedores OCI ---siendo Docker la primera herramienta
que se popularizó de estos, sobre 2013--- permite que el desarrollador
disponga en su máquina de un entorno muy similar al de la máquina donde
correrá ese _software_. Esto es verdad hasta cierto punto. TKTK. Nix
---sobretodo con la funcionalidad [_flakes_][]--- permite acercarse más a
esto. TKTK.

<!--
Mencionas que Nix se acerca más a la reproducibilidad, pero sería útil para
el lector entender por qué. Por ejemplo, podrías mencionar que las imágenes
de Docker pueden tener dependencias de sistema base que varían (p. ej.,
apt-get update en diferentes momentos), mientras que Nix fija las versiones
exactas de todas las dependencias.
-->

Nix surgió como una idea que presentó Eelco Dolstra en [su tesis doctoral][]
en la Universidad de Utretch en 2006. Pero, si somos rigurosos, Dolstra creó
tres cosas a las que se suele llamar "Nix": 1) un lenguaje específico de
dominio (_domain-specific language_ o DSL), de paradigma funcional puro muy
inspirado en Haskell, 2) un gestor de paquetes (_package manager_) como
pueden ser Homebrew o APT, y 3) una herramienta para la creación y gestión
de entornos como alternativa a cosas como los entornos `venv` del ecosistema
Python o a los contenedores Docker.

[su tesis doctoral]: https://edolstra.github.io/pubs/phd-thesis.pdf

Como verá, los entornos de Nix tienen propiedades que los hacen mucho
mejores a sus alternativas. De hecho, podríamos considerar que el fin de Nix
es su uso para entornos. Los otros dos (el lenguaje y el gestor de paquetes)
no son más que componentes que sirven para tal fin.

Nix nos proporciona ciertas propiedades que son deseables en los entornos:

- Reproducibilidad (_reproducibility_).
- Determinismo (_determinism_). Es mejor que el de los contenedores OCI,
  sobretodo cuando se habilita la funcionalidad [_flakes_][].
- Menor "basura" (_cruft_) es su sistema de archivos (_filesystem_). Es
  decir, evita que este, tras instalaciones y desinatalaciones, termine
  poblado de archivos de configuración "huérfanos", es decir, que ya no
  necesita.
- Comodidad a la hora de desarrollar. Como explicamos al comienzo de esta
  sección.

En cuanto a lo malo, se podría incluir que Nix no es más seguro que los
contenedores OCI, ya que en principio no hacen un _sandboxing_ del entorno.
Aun así, nada impide el uso de contenedores OCI en un entorno Nix. Hay quien
llega a afirmar que Nix hace mejor esto que los gestores de contenedores,
como Docker o Podman.

Además de esto, existen ciertos proyectos relacionados con Nix, como una
distribución de Linux llamada NixOS que lleva la automatización de Nix al
extremo. En esta, puede tener especificado en código Nix, además de todo el
_software_ que desee instalar en su sistema (gestión de _software_), todos
los ajustes de todo ese _software_. Lo que es una maravilla es "levantar" de
la nada un sistema justo como lo desee, a partir de uno o varios archivos de
texto; es decir, sin necesidad de ejecutables.

También se tiene a _home manager_, para macOS. TKTK.



<!--
De hecho, en mi caso particular, al igual que le sucede a muchos otros
usuarios de Nix, he pasado a instalar menos _software_ para todo el sistema
(_systemwide_) en favor de crear más frecuentemente entornos para propósitos
específicos. Por ejemplo, un _software_ que solía instalar de forma global
en mi sistema de uso personal es `yt-dlp`, que permite la descarga de vídeos
de sitios web. Ahora, lo que hago es tener un entorno en el que, cuando se
activa, se tiene de forma local dicha herramienta. Esto es muy propicio para
herramientas del tipo de `yt-dlp`, que en realidad son más bien bibliotecas
(_libraries_). TKTK.
-->






